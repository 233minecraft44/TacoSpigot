From c7e409831efdb1ccb1a80ae4f9ad551df07fd4fa Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Fri, 24 Jul 2015 16:20:18 -0700
Subject: [PATCH] Fix hopper lag by making entities look for hoppers.

Every tick hoppers try and find an inventory to extract from, if no tile
entity is above the hopper (which there often isn't) it will do a bounding
box search for minecart chests and minecart hoppers.
If it can't find an inventory, it will then look for a dropped item, which is another bounding box search.
This patch eliminates that expensive check by having dropped items and minecart hoppers/chests look for hoppers instead.
Hoppers are tile entitys meaning you can do a few simple map lookups (7 max) to find the nearest hopper in range.
Pushing out of hoppers causes a bouding box lookup, which this patch replaces with a map lookup.
This patch may cause problems if you have an insane amout of dropped items, which is why it can be disabled in the configuration.

diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 1f8b1c7..63cd4bd 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -4,6 +4,7 @@ import java.util.Iterator;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.event.player.PlayerPickupItemEvent; // CraftBukkit
+import net.techcable.tacospigot.HopperHelper; // TacoSpigot
 
 public class EntityItem extends Entity {
 
@@ -59,6 +60,7 @@ public class EntityItem extends Entity {
             this.die();
         } else {
             super.t_();
+            if (HopperHelper.acceptItemEntity(this)) return; // TacoSpigot
             // CraftBukkit start - Use wall time for pickup and despawn timers
             int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
             if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
@@ -124,6 +126,7 @@ public class EntityItem extends Entity {
     // Spigot start - copied from above
     @Override
     public void inactiveTick() {
+        if (HopperHelper.acceptItemEntity(this)) return; // TacoSpigot
         // CraftBukkit start - Use wall time for pickup and despawn timers
         int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
         if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
diff --git a/src/main/java/net/minecraft/server/EntityMinecartContainer.java b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
index c6487f2..8ca2d29 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartContainer.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
@@ -7,6 +7,7 @@ import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.inventory.InventoryHolder;
 // CraftBukkit end
+import net.techcable.tacospigot.HopperHelper; // TacoSpigot
 
 public abstract class EntityMinecartContainer extends EntityMinecartAbstract implements ITileInventory {
 
@@ -60,6 +61,20 @@ public abstract class EntityMinecartContainer extends EntityMinecartAbstract imp
 
     }
 
+    // TacoSpigot start
+    @Override
+    public void t_() {
+        super.t_();
+        HopperHelper.acceptItem(this, this);
+    }
+
+    @Override
+    public void inactiveTick() {
+        super.inactiveTick();
+        HopperHelper.acceptItem(this, this);
+    }
+    // TacoSpigot end
+
     public ItemStack getItem(int i) {
         return this.items[i];
     }
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index cab636a..ece9858 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -18,6 +18,25 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
     private String f;
     private int g = -1;
 
+    // TacoSpigot start - Have items push themselves into the hopper instead of the hopper pulling them in
+    public boolean acceptItem(EntityItem entityItem) {
+        if (!isWantItem()) return false;
+        boolean didAccept = a(this, entityItem);
+        if (didAccept) onAccept();
+        return didAccept;
+    }
+
+    public boolean isWantItem() {
+        return !n() && !this.q() && BlockHopper.f(this.u());
+    }
+
+    private void onAccept() {
+        this.d(world.spigotConfig.hopperTransfer);
+        this.update();
+    }
+
+    // TacoSpigot end
+
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
     private int maxStack = MAX_STACK;
@@ -174,7 +193,27 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
             --this.g;
             if (!this.n()) {
                 this.d(0);
-                this.m();
+                // TacoSpigot start
+                if (!world.tacoSpigotConfig.isHopperPushBased) {
+                    this.m(); // m() handles everything
+                } else if (BlockHopper.f(this.u())) { // Otherwise entities look for us and we look for tiles
+                    TileEntity above = world.getTileEntityIfLoaded(getPosition().up());
+                    boolean needsUpdate = false;
+
+                    if (!this.p()) {
+                        needsUpdate = this.r();
+                    }
+
+                    if (above != null && above instanceof IInventory) {
+                        needsUpdate = acceptItem(this, (IInventory)above) || needsUpdate;
+                    }
+
+                    if (needsUpdate) {
+                        this.d(world.spigotConfig.hopperTransfer);
+                        this.update();
+                    }
+                }
+                // TacoSpigot end
             }
 
         }
@@ -236,7 +275,10 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
     }
 
     private boolean r() {
-        IInventory iinventory = this.H();
+        // TacoSpigot start - Don't use inefficient H() which does another bounding box search
+        TileEntity tile = getWorld().getTileEntityIfLoaded(getPosition().shift(BlockHopper.b(this.u())));
+        IInventory iinventory = tile instanceof IInventory ? (IInventory) tile : null;
+        // TacoSpigot end
 
         if (iinventory == null) {
             return false;
@@ -341,9 +383,25 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return true;
     }
 
+    // TacoSpigot start - Split methods, one that pushes and one that pulls
+    @Deprecated
     public static boolean a(IHopper ihopper) {
+        if (!ihopper.getWorld().tacoSpigotConfig.isHopperPushBased) throw new AssertionError("hoppers should not be using TileEntityHopper.a(IHopper) in push-mode");
         IInventory iinventory = b(ihopper);
+        // Find and tick nearby entities, from below
+        Iterator iterator = a(ihopper.getWorld(), ihopper.A(), ihopper.B() + 1.0D, ihopper.C()).iterator();
+        while (iterator.hasNext()) {
+            EntityItem entityitem = (EntityItem) iterator.next();
+
+            if (a(ihopper, entityitem)) {
+                return true;
+            }
+        }
+        return acceptItem(ihopper, iinventory);
+    }
 
+    public static boolean acceptItem(IHopper ihopper, IInventory iinventory) {
+        // TacoSpigot end
         if (iinventory != null) {
             EnumDirection enumdirection = EnumDirection.DOWN;
 
@@ -357,6 +415,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
 
                 for (int i = 0; i < aint.length; ++i) {
                     if (a(ihopper, iinventory, aint[i], enumdirection)) {
+                        if (ihopper instanceof TileEntityHopper) ((TileEntityHopper) ihopper).onAccept(); // TacoSpigot - notify of accept
                         return true;
                     }
                 }
@@ -365,11 +424,14 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
 
                 for (int k = 0; k < j; ++k) {
                     if (a(ihopper, iinventory, k, enumdirection)) {
+                        if (ihopper instanceof TileEntityHopper) ((TileEntityHopper) ihopper).onAccept(); // TacoSpigot - notify of accept
                         return true;
                     }
                 }
             }
         } else {
+            // TacoSpigot start - move above to pull based system
+            /*
             Iterator iterator = a(ihopper.getWorld(), ihopper.A(), ihopper.B() + 1.0D, ihopper.C()).iterator();
 
             while (iterator.hasNext()) {
@@ -379,6 +441,8 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
                     return true;
                 }
             }
+            */
+            // TacoSpigot end
         }
 
         return false;
diff --git a/src/main/java/net/techcable/tacospigot/HopperHelper.java b/src/main/java/net/techcable/tacospigot/HopperHelper.java
new file mode 100644
index 0000000..82922f0
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/HopperHelper.java
@@ -0,0 +1,85 @@
+package net.techcable.tacospigot;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityItem;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.World;
+
+import com.google.common.collect.ImmutableList;
+
+public class HopperHelper {
+
+    public static boolean acceptItem(TileEntity entity, IInventory inventory) {
+        if (!entity.getWorld().tacoSpigotConfig.isHopperPushBased) return false;
+        ImmutableList<TileEntityHopper> hoppers = getHoppers(entity.getWorld(), entity.getPosition());
+        return acceptItem(hoppers, inventory);
+    }
+
+    public static boolean acceptItem(Entity entity, IInventory inventory) {
+        if (!entity.getWorld().tacoSpigotConfig.isHopperPushBased) return false;
+        ImmutableList<TileEntityHopper> acceptors = getAcceptors(entity.getWorld(), entity.locX, entity.locY, entity.locZ);
+        return acceptItem(acceptors, inventory);
+    }
+
+    public static boolean acceptItemEntity(EntityItem entity) {
+        if (!entity.getWorld().tacoSpigotConfig.isHopperPushBased) return false;
+        if (!entity.isAlive()) return false;
+        ImmutableList<TileEntityHopper> acceptors = getAcceptors(entity.getWorld(), entity.locX, entity.locY, entity.locZ);
+        for (TileEntityHopper hopper : acceptors) {
+            if (hopper.acceptItem(entity)) return true;
+        }
+        return false;
+    }
+
+    private static boolean acceptItem(ImmutableList<TileEntityHopper> acceptors, IInventory inventory) {
+        for (TileEntityHopper acceptor : acceptors) {
+            if (acceptItem(acceptor, inventory)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean acceptItem(TileEntityHopper hopper, IInventory inventory) {
+        if (!hopper.isWantItem()) return false;
+        return TileEntityHopper.acceptItem(hopper, inventory);
+    }
+
+    // Finding the acceptors
+
+    private static ImmutableList<TileEntityHopper> getAcceptors(World world, double x, double y, double z) {
+        List<TileEntityHopper> hoppers = new ArrayList<TileEntityHopper>(7);
+        // Vanilla checks for all items in a 0.5 block range, so we have to check for all hoppers in a 0.5 block range
+        // This is a much simpler check and is the main benefit of our optimization
+        double range = 0.5;
+        Set<BlockPosition> positions = new HashSet<BlockPosition>(7); // Eliminate duplicates
+        positions.add(new BlockPosition(x, y, z));
+        positions.add(new BlockPosition(x + range, y, z));
+        positions.add(new BlockPosition(x, y + range, z));
+        positions.add(new BlockPosition(x, y, z + range));
+        positions.add(new BlockPosition(x - range, y, z));
+        positions.add(new BlockPosition(x, y - range, z));
+        positions.add(new BlockPosition(x, y, z - range));
+        for (BlockPosition position : positions) {
+            TileEntity tile = world.getTileEntityIfLoaded(position);
+            if (tile == null || !(tile instanceof TileEntityHopper)) continue;
+            hoppers.add((TileEntityHopper) tile);
+        }
+        return ImmutableList.copyOf(hoppers);
+    }
+
+    private static ImmutableList<TileEntityHopper> getHoppers(World world, BlockPosition position) {
+        TileEntity tile = world.getTileEntityIfLoaded(position);
+        if (tile == null || !(tile instanceof TileEntityHopper)) return ImmutableList.of();
+        return ImmutableList.of((TileEntityHopper) tile);
+    }
+
+}
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
index 456aee9..871535f 100644
--- a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
@@ -63,4 +63,9 @@ public class TacoSpigotWorldConfig {
         config.addDefault("world-settings.default." + path, def);
         return config.getString("world-settings." + worldName + "." + path, config.getString("world-settings.default." + path));
     }
+
+    public boolean isHopperPushBased;
+    private void isHopperPushBased() {
+        isHopperPushBased = getBoolean("hopper.push-based", true);
+    }
 }
-- 
2.4.6.windows.1

