From 1c6186f153fd9709776948fa5929aa2b99ba122e Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Sat, 5 Sep 2015 18:38:09 -0700
Subject: [PATCH] Optimize world.getType() and world.getChunkAt()

Speeds up world.isValidPosition() by only checking for a valid y.
Checks for valid x and zs are only performed when chunks are (attempting)
loading.
Some minor optimizations to Chunk.getBlockData() and World.getChunkAt()

Should help with everything from redstone to entities.

diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index e0bc8aa..5284187 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -507,7 +507,7 @@ public class Chunk {
     }
 
     public IBlockData getBlockData(final BlockPosition blockposition) {
-        if (this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+        if (false /* this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES*/) { // TacoSpigot - never 'DEBUG_ALL_BLOCK_STATES'
             IBlockData iblockdata = null;
 
             if (blockposition.getY() == 60) {
@@ -521,7 +521,8 @@ public class Chunk {
             return iblockdata == null ? Blocks.AIR.getBlockData() : iblockdata;
         } else {
             try {
-                if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
+                // TacoSpigot - assume the 'y' is a valid position (usually true due to a World.isValidPosition check)
+                // if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
                     ChunkSection chunksection = this.sections[blockposition.getY() >> 4];
 
                     if (chunksection != null) {
@@ -530,9 +531,11 @@ public class Chunk {
                         int k = blockposition.getZ() & 15;
 
                         return chunksection.getType(i, j, k);
-                    }
-                }
-
+                        // TacoSpigot start
+                    } else return Blocks.AIR.getBlockData();
+                // }
+                // TacoSpigot end
+            } catch (IndexOutOfBoundsException e) { // TacoSpigot - handle cases where blockposition.getY() is not valid
                 return Blocks.AIR.getBlockData();
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 0e6a37f..9cce946 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -22,11 +22,16 @@ import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.util.LongObjectHashMap;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
+// TacoSpigot start
+import gnu.trove.set.hash.TLongHashSet;
+import net.techcable.tacospigot.ILongHashSet;
+import net.techcable.tacospigot.TroveLongHashSet;
+// TacoSpigot end
 
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger b = LogManager.getLogger();
-    public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    public ILongHashSet unloadQueue = new TroveLongHashSet(new TLongHashSet()); // CraftBukkit - LongHashSet // TacoSpigot - use trove
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
     private IChunkLoader chunkLoader;
@@ -114,9 +119,15 @@ public class ChunkProviderServer implements IChunkProvider {
         return getChunkAt(i, j, null);
     }
 
+    // TacoSpigot start - cache the most recently returned chunk
+    private Chunk lastChunk = null;
     public Chunk getChunkAt(int i, int j, Runnable runnable) {
+        if (lastChunk != null && lastChunk.locX == i && lastChunk.locZ == j) return lastChunk;
+        // TacoSpigot end
         unloadQueue.remove(i, j);
         Chunk chunk = chunks.get(LongHash.toLong(i, j));
+        if (chunk == null) { // TacoSpigot - optimize cases where the chunk is in the map
+        if (!World.isValidChunk(i, j)) throw new IllegalArgumentException("Invalid chunk position " + i + " " + j); // TacoSpigot - throw IllegalArgumentException instead of loading a invalid chunk
         ChunkRegionLoader loader = null;
 
         if (this.chunkLoader instanceof ChunkRegionLoader) {
@@ -124,22 +135,24 @@ public class ChunkProviderServer implements IChunkProvider {
 
         }
         // We can only use the queue for already generated chunks
-        if (chunk == null && loader != null && loader.chunkExists(world, i, j)) {
+        if (loader != null && loader.chunkExists(world, i, j)) { // TacoSpigot
             if (runnable != null) {
                 ChunkIOExecutor.queueChunkLoad(world, loader, this, i, j, runnable);
                 return null;
             } else {
                 chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
             }
-        } else if (chunk == null) {
+        } else { // TacoSpigot
             chunk = originalGetChunkAt(i, j);
         }
+        } // TacoSpigot - close 'if (chunk == null)
 
         // If we didn't load the chunk async and have a callback run it now
         if (runnable != null) {
             runnable.run();
         }
 
+        lastChunk = chunk; // TacoSpigot - cache the chunk
         return chunk;
     }
     public Chunk originalGetChunkAt(int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 158646b..171fa28 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -28,6 +28,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
     // CraftBukkit start
     public boolean chunkExists(World world, int i, int j) {
+        if (!World.isValidChunk(i, j)) return false; // TacoSpigot - ensure valid
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
         if (this.c.contains(chunkcoordintpair)) {
@@ -56,6 +57,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
     }
 
     public Object[] loadChunk(World world, int i, int j) throws IOException {
+        if (!World.isValidChunk(i, j)) return null; // TacoSpigot - ensure valid
         // CraftBukkit end
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
         NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.get(chunkcoordintpair);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 9008c56..e2d1558 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -281,9 +281,23 @@ public abstract class World implements IBlockAccess {
         return this.getType(blockposition1).getBlock();
     }
 
-    private boolean isValidLocation(BlockPosition blockposition) {
-        return blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 && blockposition.getY() >= 0 && blockposition.getY() < 256;
+    // TacoSpigot - start optimize isValidLocation
+    /* We check for a valid x and z in loadChunk() by calling isValidChunk
+     * This means we never load an invalid chunk, and avoid a check for invalid chunks for getting from the hash map
+     * In addition, since chunk positions are smaller (by 16 times), bitwise comparisons should be faster
+     * Also we make it static to inline it easier
+     * Make sure to update isValidChunk() whenever isValidLocation() changes
+     */
+    public static boolean isValidLocation(BlockPosition blockposition) {
+        return /*blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 &&*/ blockposition.getY() >= 0 && blockposition.getY() < 256;
+    }
+
+    private static final int MIN_CHUNK_XZ =  -30000000 >> 4;
+    private static final int MAX_CHUNK_XZ = 30000000 >> 4; // You have to do a '<' check here instead of a '<=' check (IDK why)
+    public static boolean isValidChunk(int x, int z) {
+        return x >= MIN_CHUNK_XZ && z >= MIN_CHUNK_XZ && x < MAX_CHUNK_XZ && z < MAX_CHUNK_XZ;
     }
+    // TacoSpigot end
 
     public boolean isEmpty(BlockPosition blockposition) {
         return this.getType(blockposition).getBlock().getMaterial() == Material.AIR;
@@ -780,9 +794,15 @@ public abstract class World implements IBlockAccess {
         if (!this.isValidLocation(blockposition)) {
             return Blocks.AIR.getBlockData();
         } else {
+            // TacoSpigot start - handle invalid chunk positions
+            try {
             Chunk chunk = this.getChunkAtWorldCoords(blockposition);
 
             return chunk.getBlockData(blockposition);
+            } catch (IllegalArgumentException e) {
+                return Blocks.AIR.getBlockData();
+            }
+            // TacoSpigot end
         }
     }
 
diff --git a/src/main/java/net/techcable/tacospigot/ILongHashSet.java b/src/main/java/net/techcable/tacospigot/ILongHashSet.java
new file mode 100644
index 0000000..ffe7134
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/ILongHashSet.java
@@ -0,0 +1,71 @@
+package net.techcable.tacospigot;
+
+import gnu.trove.TDecorators;
+import gnu.trove.iterator.TIntIterator;
+import gnu.trove.iterator.TLongIterator;
+import org.bukkit.craftbukkit.util.LongHash;
+
+import java.util.Arrays;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * An interface to the methods in {@link org.bukkit.craftbukkit.util.LongHashSet}
+ */
+public interface ILongHashSet {
+
+    public TLongIterator primitiveIterator();
+
+    public default Iterator<Long> iterator() {
+        TLongIterator primitive = primitiveIterator();
+        return new Iterator<Long>() {
+            @Override
+            public boolean hasNext() {
+                return primitive.hasNext();
+            }
+
+            @Override
+            public Long next() {
+                return primitive.next();
+            }
+
+            @Override
+            public void remove() {
+                primitive.remove();
+            }
+        };
+    }
+
+    public int size();
+
+    public default boolean isEmpty() {
+        return size() == 0;
+    }
+
+    public default boolean contains(int msw, int lsw) {
+        return contains(LongHash.toLong(msw, lsw));
+    }
+
+    public boolean contains(long value);
+
+    public default boolean add(int msw, int lsw) {
+        return add(LongHash.toLong(msw, lsw));
+    }
+
+    public boolean add(long value);
+
+    public default void remove(int msw, int lsw) {
+        remove(LongHash.toLong(msw, lsw));
+    }
+
+    public boolean remove(long value);
+
+    public void clear();
+
+    public long[] toArray();
+
+    public long popFirst();
+
+    public long[] popAll();
+}
\ No newline at end of file
diff --git a/src/main/java/net/techcable/tacospigot/TroveLongHashSet.java b/src/main/java/net/techcable/tacospigot/TroveLongHashSet.java
new file mode 100644
index 0000000..8fb6c6e
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/TroveLongHashSet.java
@@ -0,0 +1,77 @@
+package net.techcable.tacospigot;
+
+import gnu.trove.iterator.TLongIterator;
+import gnu.trove.procedure.TLongProcedure;
+import gnu.trove.set.hash.TLongHashSet;
+
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+
+public class TroveLongHashSet implements ILongHashSet {
+    private final TLongHashSet delegate;
+    private final boolean concurrent;
+
+    public TroveLongHashSet(TLongHashSet delegate, boolean concurrent) {
+        this.delegate = delegate;
+        this.concurrent = concurrent;
+    }
+
+    public TroveLongHashSet(TLongHashSet delegate) {
+        this(delegate, false);
+    }
+
+    @Override
+    public TLongIterator primitiveIterator() {
+        return delegate.iterator();
+    }
+
+    @Override
+    public int size() {
+        return delegate.size();
+    }
+
+    @Override
+    public boolean contains(long value) {
+        return delegate.contains(value);
+    }
+
+    @Override
+    public boolean add(long value) {
+        return delegate.add(value);
+    }
+
+    @Override
+    public boolean remove(long value) {
+        return delegate.remove(value);
+    }
+
+    @Override
+    public void clear() {
+        delegate.clear();
+    }
+
+    @Override
+    public long[] toArray() {
+        return delegate.toArray();
+    }
+
+    @Override
+    public long popFirst() {
+        TLongIterator iterator = primitiveIterator();
+        if (iterator.hasNext()) {
+            long l = iterator.next();
+            boolean removed = remove(l);
+            if (!removed && concurrent) return popFirst(); // Someone else removed concurrently
+        }
+        return 0;
+    }
+
+    @Override
+    public long[] popAll() {
+        long[] longs = toArray();
+        if (concurrent) delegate.removeAll(longs);
+        else clear();
+        return longs;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
index a213579..87413c3 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LongHashSet.java
@@ -16,12 +16,14 @@
 
 package org.bukkit.craftbukkit.util;
 
+import gnu.trove.iterator.TLongIterator;
+
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.ConcurrentModificationException;
 import java.util.NoSuchElementException;
 
-public class LongHashSet {
+public class LongHashSet implements net.techcable.tacospigot.ILongHashSet { // TacoSpigot - implement our interface
     private final static int INITIAL_SIZE = 3;
     private final static double LOAD_FACTOR = 0.75;
 
@@ -44,9 +46,13 @@ public class LongHashSet {
         modCount = 0;
     }
 
+    // TacoSpigot start - use default implementation
+    /*
     public Iterator iterator() {
         return new Itr();
     }
+    */
+    // TacoSpigot end
 
     public int size() {
         return elements;
@@ -243,7 +249,14 @@ public class LongHashSet {
         freeEntries = values.length - elements;
     }
 
-    private class Itr implements Iterator {
+    // TacoSpigot start - iterate primitive ints
+    @Override
+    public TLongIterator primitiveIterator() {
+        return new Itr();
+    }
+
+    private class Itr implements gnu.trove.iterator.TLongIterator {
+        // TacoSpigot end
         private int index;
         private int lastReturned = -1;
         private int expectedModCount;
@@ -259,7 +272,7 @@ public class LongHashSet {
             return index != values.length;
         }
 
-        public Long next() {
+        public long next() { // TacoSpigot - return primitive
             if (modCount != expectedModCount) {
                 throw new ConcurrentModificationException();
             }
diff --git a/src/test/java/net/techcable/tacospigot/LongHashSetTest.java b/src/test/java/net/techcable/tacospigot/LongHashSetTest.java
new file mode 100644
index 0000000..a154910
--- /dev/null
+++ b/src/test/java/net/techcable/tacospigot/LongHashSetTest.java
@@ -0,0 +1,73 @@
+package net.techcable.tacospigot;
+
+import gnu.trove.iterator.TLongIterator;
+import gnu.trove.list.TLongList;
+import gnu.trove.list.array.TLongArrayList;
+import gnu.trove.set.hash.TLongHashSet;
+import org.bukkit.craftbukkit.util.LongHashSet;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class LongHashSetTest {
+    private ILongHashSet set;
+
+    // Test functions
+
+    @Test
+    public void testTrove() {
+        set = new TroveLongHashSet(new TLongHashSet());
+        testAdd();
+        testContains();
+        testIterator();
+        testRemove();
+    }
+
+
+    @Test
+    @Ignore // Who cares if bukkit is bugged ?
+    public void testBukkit() {
+        set = new LongHashSet();
+        testAdd();
+        testContains();
+        testIterator();
+        testRemove();
+    }
+
+
+    public static final int MAX_TEST = 10000;
+    private void testAdd() {
+        for (int i = 0; i < MAX_TEST; i++) {
+            assertTrue("Could not add " + i + " to " + set.getClass().getSimpleName(), set.add(i));
+        }
+    }
+
+    private void testContains() {
+        for (int i = 0; i < MAX_TEST; i++) {
+            assertTrue(set.getClass().getSimpleName() + " did not contain " + i, set.contains(i));
+        }
+    }
+
+    private void testRemove() {
+        for (int i = 0; i < MAX_TEST; i++) {
+            assertTrue("Could not remove " + i + " from " + set.getClass().getSimpleName(), set.remove(i));
+        }
+    }
+
+    private void testIterator() {
+        TLongList needed = new TLongArrayList(MAX_TEST); // We are lucky that the hash code is mostly in order
+        for (int i = 0; i < MAX_TEST; i++) needed.add(i);
+        TLongIterator iterator = set.primitiveIterator();
+        while (iterator.hasNext()) {
+            long l = iterator.next();
+            int indexOfNeeded = needed.lastIndexOf(l);
+            assertNotEquals("Could not find " + l + " in " + MAX_TEST, indexOfNeeded, -1);
+            needed.removeAt(indexOfNeeded);
+        }
+        if (!needed.isEmpty()) {
+            throw new AssertionError("Iterator could not find " + needed.get(0));
+        }
+    }
+
+}
-- 
2.4.6.windows.1.812.gd1b00d3

