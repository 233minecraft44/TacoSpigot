From 10cb4f6dd961b5694c19cbf7a476951fbaba4e55 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Wed, 2 Sep 2015 22:17:43 -0700
Subject: [PATCH] Add a per-type tick limiter

Limits for one type have no effect on other types.
When the limit for one type is reached, further entities and tiles of that
type will wait until they are ticked.
Before the tick runs, the server prioritizes stuff in the queue.
If the queue could not run to completion (due to limits), then tiles of that type will not be added to the queue during the tick to prevent infinite queue growth.

Requires java 8.
Avoids hash map lookups.

diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d7b0dc6..e087464 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -178,7 +178,14 @@ public abstract class Entity implements ICommandListener {
         this.datawatcher.a(2, "");
         this.datawatcher.a(4, Byte.valueOf((byte) 0));
         this.h();
+        // TacoSpigot start - store type ids
+        this.typeId = net.techcable.tacospigot.TypeIds.getEntityTypeId(getClass());
     }
+    private final int typeId;
+    public int getTypeId() {
+        return typeId;
+    }
+    // TacoSpigot end
 
     protected abstract void h();
 
diff --git a/src/main/java/net/minecraft/server/EntityTypes.java b/src/main/java/net/minecraft/server/EntityTypes.java
index 064d0b2..edcce5c 100644
--- a/src/main/java/net/minecraft/server/EntityTypes.java
+++ b/src/main/java/net/minecraft/server/EntityTypes.java
@@ -13,7 +13,7 @@ import org.apache.logging.log4j.Logger;
 public class EntityTypes {
 
     private static final Logger b = LogManager.getLogger();
-    private static final Map<String, Class<? extends Entity>> c = Maps.newHashMap();
+    public static final Map<String, Class<? extends Entity>> c = Maps.newHashMap(); // TacoSpigot - expose
     private static final Map<Class<? extends Entity>, String> d = Maps.newHashMap();
     private static final Map<Integer, Class<? extends Entity>> e = Maps.newHashMap();
     private static final Map<Class<? extends Entity>, Integer> f = Maps.newHashMap();
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index d258604..9cda0af 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.concurrent.Callable;
+
+import net.techcable.tacospigot.TypeIds;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -14,7 +16,7 @@ public abstract class TileEntity {
     public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static final Logger a = LogManager.getLogger();
     private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
-    private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();
+    public static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap(); // TacoSpigot - expose
     protected World world;
     protected BlockPosition position;
     protected boolean d;
@@ -30,7 +32,15 @@ public abstract class TileEntity {
     public TileEntity() {
         this.position = BlockPosition.ZERO;
         this.h = -1;
+        // TacoSpigot start
+        this.typeId = TypeIds.getTileTypeId(getClass());
+    }
+    private final int typeId;
+
+    public int getTypeId() {
+        return typeId;
     }
+    // TacoSpigot end
 
     private static void a(Class<? extends TileEntity> oclass, String s) {
         if (TileEntity.f.containsKey(s)) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 9008c56..681ee18 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -121,7 +121,7 @@ public abstract class World implements IBlockAccess {
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     public boolean populating;
-    private int tickPosition;
+    // private int tickPosition; // TacoSpigot - per type tick limiting
 
     // Spigot start
     private boolean guardEntityList;
@@ -131,7 +131,7 @@ public abstract class World implements IBlockAccess {
     private final byte chunkTickRadius;
     public static boolean haveWeSilencedAPhysicsCrash;
     public static String blockLocation;
-    private int tileTickPosition;
+    // private int tileTickPosition; // TacoSpigot - per type tick limiting
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
 
@@ -1130,9 +1130,13 @@ public abstract class World implements IBlockAccess {
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
         int index = this.entityList.indexOf(entity);
         if (index != -1) {
+            // TacoSpigot start - per type tick limiting
+            /*
             if (index <= this.tickPosition) {
                 this.tickPosition--;
             }
+            */
+            // TacoSpigot end
             this.entityList.remove(index);
         }
         // CraftBukkit end
@@ -1359,12 +1363,12 @@ public abstract class World implements IBlockAccess {
         this.methodProfiler.a("global");
 
         int i;
-        Entity entity;
+        // Entity entity; // TacoSpigot - limit scope to allow use in lambada
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
         for (i = 0; i < this.k.size(); ++i) {
-            entity = (Entity) this.k.get(i);
+            Entity entity = (Entity) this.k.get(i); // TacoSpigot - declare with limited scope
             // CraftBukkit start - Fixed an NPE
             if (entity == null) {
                 continue;
@@ -1394,13 +1398,19 @@ public abstract class World implements IBlockAccess {
         this.methodProfiler.c("remove");
         this.entityList.removeAll(this.g);
 
+        // TacoSpigot start - use a limited scope to alow for re-declaration in a lambada
+        /*
         int j;
         int k;
+        */
+        // TacoSpigot end
 
         for (i = 0; i < this.g.size(); ++i) {
-            entity = (Entity) this.g.get(i);
-            j = entity.ae;
-            k = entity.ag;
+            // TacoSpigot start - declare with limited scope
+            Entity entity = (Entity) this.g.get(i);
+            int j = entity.ae;
+            int k = entity.ag;
+            // TacoSpigot end
             if (entity.ad && this.isChunkLoaded(j, k, true)) {
                 this.getChunkAt(j, k).b(entity);
             }
@@ -1416,13 +1426,19 @@ public abstract class World implements IBlockAccess {
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
         guardEntityList = true; // Spigot
+        // TacoSpigot start - limit entity ticking
+        Set<Object> toRemove = new HashSet<>();
+        /*
         // CraftBukkit start - Use field for loop variable
         for (this.tickPosition = 0; this.tickPosition < this.entityList.size(); ++this.tickPosition) {
             entity = (Entity) this.entityList.get(this.tickPosition);
+            */
+        tacoSpigotConfig.entityLimiter.tick(entityList, (entity) -> {
+            // TacoSpigot end
             // CraftBukkit end
             if (entity.vehicle != null) {
                 if (!entity.vehicle.dead && entity.vehicle.passenger == entity) {
-                    continue;
+                    return; // TacoSpigot - return instead of continuing
                 }
 
                 entity.vehicle.passenger = null;
@@ -1441,7 +1457,7 @@ public abstract class World implements IBlockAccess {
                     System.err.println("Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ);
                     throwable1.printStackTrace();
                     entity.dead = true;
-                    continue;
+                    return; // TacoSpigot - return instead of continuing
                     // PaperSpigot end
                 }
             }
@@ -1449,20 +1465,26 @@ public abstract class World implements IBlockAccess {
             this.methodProfiler.b();
             this.methodProfiler.a("remove");
             if (entity.dead) {
-                j = entity.ae;
-                k = entity.ag;
+                // TacoSpigot start - declare again inside lambada
+                int j = entity.ae;
+                int k = entity.ag;
+                // TacoSpigot end
                 if (entity.ad && this.isChunkLoaded(j, k, true)) {
                     this.getChunkAt(j, k).b(entity);
                 }
 
                 guardEntityList = false; // Spigot
-                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                toRemove.add(entity); // CraftBukkit - Use field for loop variable // TacoSpigot - queue removals to prevent CME
                 guardEntityList = true; // Spigot
                 this.b(entity);
             }
 
             this.methodProfiler.b();
-        }
+            // TacoSpigot start - remove all queued removals
+        }); // fix syntax
+        entityList.removeAll(toRemove);
+        toRemove.clear();
+        // TacoSpigot end
         guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
@@ -1476,14 +1498,20 @@ public abstract class World implements IBlockAccess {
             this.c.clear();
         }
         // CraftBukkit end
+        // TacoSpigot start - limit tile entity ticking
+        toRemove.clear();
+        /*
         Iterator iterator = this.tileEntityList.iterator();
 
         while (iterator.hasNext()) {
             TileEntity tileentity = (TileEntity) iterator.next();
+            */
+        tacoSpigotConfig.tileLimiter.tick(tileEntityList, (tileentity) -> {
+            // TacoSpigot end
             if (tileentity == null) {
                 getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
-                iterator.remove();
-                continue;
+                toRemove.add(tileentity); // TacoSpigot - queue removals to prevent CME
+                return; // TacoSpigot - use return instead of continue
             }
             // Spigot end
 
@@ -1499,8 +1527,8 @@ public abstract class World implements IBlockAccess {
                         tileentity.tickTimer.stopTiming();
                         System.err.println("TileEntity threw exception at " + tileentity.world.getWorld().getName() + ":" + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ());
                         throwable2.printStackTrace();
-                        iterator.remove();
-                        continue;
+                        toRemove.add(tileentity); // TacoSpigot - queue removals to prevent CME
+                        return; // TacoSpigot - use return instead of continue
                         // PaperSpigot end
                     }
                     // Spigot start
@@ -1512,14 +1540,17 @@ public abstract class World implements IBlockAccess {
             }
 
             if (tileentity.x()) {
-                iterator.remove();
+                toRemove.add(tileentity); // TacoSpigot - queue removals to prevent CME
                 this.h.remove(tileentity);
                 if (this.isLoaded(tileentity.getPosition())) {
                     this.getChunkAtWorldCoords(tileentity.getPosition()).e(tileentity.getPosition());
                 }
             }
-        }
-
+            // TacoSpigot start - remove queued
+        }); // fix syntax
+        tileEntityList.removeAll(toRemove);
+        toRemove.clear();
+        // TacoSpigot end
         timings.tileEntityTick.stopTiming(); // Spigot
         timings.tileEntityPending.startTiming(); // Spigot
         this.M = false;
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
index 58f335d..9ae3a70 100644
--- a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
@@ -1,9 +1,21 @@
 package net.techcable.tacospigot;
 
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
+import com.google.common.base.Preconditions;
+import net.minecraft.server.Block;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityTypes;
+import net.minecraft.server.TileEntity;
+import net.techcable.tacospigot.limit.EntityLimiter;
+import net.techcable.tacospigot.limit.TileLimiter;
+import org.apache.commons.lang3.text.WordUtils;
 import org.bukkit.Bukkit;
+import org.bukkit.Material;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.entity.EntityType;
 
 public class TacoSpigotWorldConfig {
 
@@ -83,4 +95,114 @@ public class TacoSpigotWorldConfig {
     private void isArmorStandLookForMinecart() {
         isArmorStandLookForMinecart = getBoolean("armor-stand.look-for-minecart", true); // Most servers will have more minecarts than armor stands
     }
+
+    public EntityLimiter entityLimiter = new EntityLimiter();
+    private void entityLimits() {
+        List<String> defaultLimits = new ArrayList<>();
+        for (String internalName : EntityTypes.c.keySet()) {
+            EntityType bukkitEntityType = EntityType.fromName(internalName);
+            Preconditions.checkNotNull(bukkitEntityType, "No bukkit entity type for internal name %s", internalName);
+            String entityName = bukkitEntityType.name();
+            entityName = entityName.replace('_', ' ');
+            entityName = WordUtils.capitalizeFully(entityName);
+            String time = "-1 ms";
+            String limitSpecifer = entityName + ":" + time;
+            defaultLimits.add(limitSpecifer);
+        }
+        List<String> limits = getList("limits.entity", defaultLimits);
+        for (String raw : limits) {
+            String[] parts = raw.split(":");
+            if (parts.length < 2) {
+                Bukkit.getLogger().warning("Invalid limit specification " + raw);
+                continue;
+            }
+            String entityTypeName = parts[0];
+            EntityType bukkitEntityType = EntityType.fromName(entityTypeName);
+            if (bukkitEntityType == null) {
+                entityTypeName = entityTypeName.toUpperCase();
+                entityTypeName = entityTypeName.replaceAll("[- ]", "_");
+                try {
+                    bukkitEntityType = EntityType.valueOf(entityTypeName);
+                } catch (IllegalArgumentException e) {
+                    Bukkit.getLogger().warning("Invalid entity name " + parts[0]);
+                    continue;
+                }
+            }
+            String limitTxt = parts[1];
+            limitTxt = limitTxt.toLowerCase();
+            limitTxt = limitTxt.replaceAll("\\sm(?:illi)?s", "");
+            long limit;
+            try {
+                limit = Long.parseLong(limitTxt);
+            } catch (NumberFormatException e) {
+                Bukkit.getLogger().warning("Invalid limit: " + parts[1]);
+                continue;
+            }
+            Class<? extends Entity> entityType = EntityTypes.c.get(bukkitEntityType.getName());
+            Preconditions.checkNotNull(entityType, "Found " + bukkitEntityType.getName() + "in bukkit but not in NMS");
+            entityLimiter.limitTime(entityType, limit);
+        }
+    }
+
+    public TileLimiter tileLimiter = new TileLimiter();
+    private void tileLimits() {
+        List<String> defaultLimits = new ArrayList<>();
+        for (Class<? extends TileEntity> tileClass : TileEntity.g.keySet()) {
+            String tileName = tileClass.getSimpleName();
+            tileName = tileName.replace("TileEntity", "");
+            // Space it out
+            StringBuilder builder = new StringBuilder();
+            for (int i = 0; i < tileName.length(); i++) {
+                char c = tileName.charAt(i);
+                if (Character.isUpperCase(c)) {
+                    builder.append(' ');
+                }
+                builder.append(c);
+            }
+            tileName = builder.toString();
+            String time = "-1 ms";
+            String limitSpecifier = tileName + ":" + time;
+            defaultLimits.add(limitSpecifier);
+        }
+        List<String> limits = getList("limits.tile", defaultLimits);
+        for (String raw : limits) {
+            String[] parts = raw.split(":");
+            if (parts.length < 2) {
+                Bukkit.getLogger().warning("Invalid limit specification " + raw);
+                continue;
+            }
+            String tileTypeName = parts[0];
+            tileTypeName = tileTypeName.replaceAll("[- ]", "");
+            Class<? extends TileEntity> tileType = null;
+            // We can't effectively implement the case changes, so we do a case-insensitive-search
+            for (Class<? extends TileEntity> tileClass : TileEntity.g.keySet()) {
+                String typeName = tileClass.getSimpleName();
+                typeName = typeName.replace("TileEntity", "");
+                if (typeName.equalsIgnoreCase(tileTypeName)) {
+                    tileType = tileClass;
+                    break;
+                }
+                typeName = TileEntity.g.get(tileClass);
+                if (typeName.equalsIgnoreCase(tileTypeName)) {
+                    tileType = tileClass;
+                    break;
+                }
+            }
+            if (tileType == null) {
+                Bukkit.getLogger().warning("Unknown tile entity type: " + parts[0]);
+                continue;
+            }
+            String limitTxt = parts[1];
+            limitTxt = limitTxt.toLowerCase();
+            limitTxt = limitTxt.replaceAll("\\sm(?:illi)?s", "");
+            long limit;
+            try {
+                limit = Long.parseLong(limitTxt);
+            } catch (NumberFormatException e) {
+                Bukkit.getLogger().warning("Invalid limit: " + parts[1]);
+                continue;
+            }
+            tileLimiter.limitTime(tileType, limit);
+        }
+    }
 }
diff --git a/src/main/java/net/techcable/tacospigot/TypeIds.java b/src/main/java/net/techcable/tacospigot/TypeIds.java
new file mode 100644
index 0000000..6da9ad0
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/TypeIds.java
@@ -0,0 +1,59 @@
+package net.techcable.tacospigot;
+
+import com.google.common.collect.ImmutableMap;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockJukeBox;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Entity;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.TileEntityBanner;
+import net.minecraft.server.TileEntityBeacon;
+import net.minecraft.server.TileEntityBrewingStand;
+import net.minecraft.server.TileEntityChest;
+import net.minecraft.server.TileEntityCommand;
+import net.minecraft.server.TileEntityComparator;
+import net.minecraft.server.TileEntityDispenser;
+import net.minecraft.server.TileEntityDropper;
+import net.minecraft.server.TileEntityEnchantTable;
+import net.minecraft.server.TileEntityEnderChest;
+import net.minecraft.server.TileEntityEnderPortal;
+import net.minecraft.server.TileEntityFlowerPot;
+import net.minecraft.server.TileEntityFurnace;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.TileEntityLightDetector;
+import net.minecraft.server.TileEntityMobSpawner;
+import net.minecraft.server.TileEntityNote;
+import net.minecraft.server.TileEntityPiston;
+import net.minecraft.server.TileEntitySign;
+import net.minecraft.server.TileEntitySkull;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class TypeIds {
+    private TypeIds() {}
+
+    private static final AtomicInteger nextTileId = new AtomicInteger();
+    private static final ConcurrentMap<Class<? extends TileEntity>, Integer> tileTypeIds = new ConcurrentHashMap<>();
+
+    public static int getTileTypeId(Class<? extends TileEntity> tileEntityClass) {
+        return tileTypeIds.computeIfAbsent(tileEntityClass, (ignored) -> nextTileId.getAndIncrement());
+    }
+
+    public static int getTypeId(TileEntity e) {
+        return e.getTypeId();
+    }
+
+    private static final AtomicInteger nextEntityId = new AtomicInteger();
+    private static final ConcurrentMap<Class<? extends Entity>, Integer> entityTypeIds = new ConcurrentHashMap<>();
+
+    public static int getEntityTypeId(Class<? extends Entity> entityClass) {
+        return entityTypeIds.computeIfAbsent(entityClass, (ignored) -> nextEntityId.getAndIncrement());
+    }
+
+    public static int getTypeId(Entity e) {
+        return e.getTypeId();
+    }
+
+}
diff --git a/src/main/java/net/techcable/tacospigot/limit/EntityLimiter.java b/src/main/java/net/techcable/tacospigot/limit/EntityLimiter.java
new file mode 100644
index 0000000..0a2e148
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/limit/EntityLimiter.java
@@ -0,0 +1,16 @@
+package net.techcable.tacospigot.limit;
+
+import net.minecraft.server.Entity;
+import net.techcable.tacospigot.TypeIds;
+
+public class EntityLimiter extends TickLimiter<Entity> {
+    @Override
+    protected int getTypeIndex(Entity obj) {
+        return TypeIds.getTypeId(obj);
+    }
+
+    @Override
+    protected int getTypeIndex(Class<? extends Entity> obj) {
+        return TypeIds.getEntityTypeId(obj);
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/limit/TickLimiter.java b/src/main/java/net/techcable/tacospigot/limit/TickLimiter.java
new file mode 100644
index 0000000..e89a186
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/limit/TickLimiter.java
@@ -0,0 +1,127 @@
+package net.techcable.tacospigot.limit;
+
+import com.google.common.base.Preconditions;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.Queue;
+import java.util.function.Consumer;
+
+public abstract class TickLimiter<T> {
+
+    //
+    // Public Methods
+    //
+
+    public void tick(Collection<T> toTick, final Consumer<T> tickFunction) {
+        forEachLimiter(l -> l.emptyQueue(tickFunction));
+        toTick.forEach(t -> {
+            TypeTickLimiter typeTickLimiter = getLimiter(t);
+            typeTickLimiter.tryTick(t, tickFunction);
+        });
+        forEachLimiter(TypeTickLimiter::endWholeTick);
+    }
+
+    public void limitTime(Class<? extends T> type, long limit) {
+        getLimiter(type).limit = limit;
+    }
+
+    // Indexing
+    @SuppressWarnings("unchecked")
+    private TypeTickLimiter[] limiters = (TypeTickLimiter[]) Array.newInstance(TypeTickLimiter.class, 10); // Create with reflection to avoid warning about generic arrays
+
+    @Deprecated
+    protected abstract int getTypeIndex(T obj);
+
+    @Deprecated
+    protected abstract int getTypeIndex(Class<? extends T> obj);
+
+    @SuppressWarnings({"deprecation", "unchecked"})
+    private TypeTickLimiter getLimiter(T type) {
+        int index = getTypeIndex(type);
+        return getLimiter(index, (Class<? extends T>) type.getClass());
+    }
+
+    @SuppressWarnings("deprecation")
+    private TypeTickLimiter getLimiter(Class<? extends T> type) {
+        int index = getTypeIndex(type);
+        return getLimiter(index, type);
+    }
+
+    @SuppressWarnings("deprecation")
+    private void forEachLimiter(Consumer<TypeTickLimiter> action) {
+        Arrays.stream(limiters).filter(l -> l != null).forEach(action);
+    }
+
+    @Deprecated
+    private TypeTickLimiter getLimiter(final int index, Class<? extends T> type) {
+        if (index >= limiters.length) {
+            Preconditions.checkState(getTypeIndex(type) == index, "map index %s is not equal to given index %s", getTypeIndex(type), index);
+            limiters = Arrays.copyOf(limiters, index + 6); // Expand by 5 more than needed
+            limiters[index] = new TypeTickLimiter(type);
+        }
+        TypeTickLimiter limiter = limiters[index];
+        if (limiter == null) {
+            limiter = new TypeTickLimiter(type);
+            limiters[index] = limiter;
+        }
+        return limiter;
+    }
+
+    //
+    // Inner Classes
+    //
+
+    private class TypeTickLimiter {
+        private final Class<? extends T> type;
+        private long limit = -1, totalTime = 0;
+        private boolean queueEmptied = false;
+        private final Queue<T> queue = new LinkedList<>();
+
+        private TypeTickLimiter(Class<? extends T> type) {
+            this.type = type;
+        }
+
+        public void emptyQueue(Consumer<T> tickFunction) {
+            T t;
+            queueEmptied = true;
+            while ((t = queue.peek()) != null) {
+                boolean ticked = tick0(t, tickFunction, false); // Don't queue it
+                if (!ticked) {
+                    queueEmptied = false;
+                    break;
+                }
+                queue.poll(); // Remove this thing from the queue
+            }
+        }
+
+        public void tryTick(T t, Consumer<T> tickFunction) {
+            // We only queue it if we managed to empty it
+            // This prevents an infinitely expanding queue
+            tick0(t, tickFunction, queueEmptied);
+        }
+
+        private boolean tick0(T t, Consumer<T> tickFunction, boolean queue) {
+            Preconditions.checkArgument(isType(t), "%s is not a %s", t.getClass().getSimpleName(), t.getClass());
+            final long start = System.currentTimeMillis();
+            if (limit < totalTime) {
+                if (queue) this.queue.add(t);
+                return false;
+            }
+            tickFunction.accept(t);
+            totalTime += System.currentTimeMillis() - start;
+            return true;
+        }
+
+        public void endWholeTick() {
+            totalTime = 0;
+            queueEmptied = false;
+        }
+
+        public boolean isType(T t) {
+            return type.isInstance(t);
+        }
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/limit/TileLimiter.java b/src/main/java/net/techcable/tacospigot/limit/TileLimiter.java
new file mode 100644
index 0000000..a474623
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/limit/TileLimiter.java
@@ -0,0 +1,16 @@
+package net.techcable.tacospigot.limit;
+
+import net.minecraft.server.TileEntity;
+import net.techcable.tacospigot.TypeIds;
+
+public class TileLimiter extends TickLimiter<TileEntity> {
+    @Override
+    protected int getTypeIndex(TileEntity obj) {
+        return TypeIds.getTypeId(obj);
+    }
+
+    @Override
+    protected int getTypeIndex(Class<? extends TileEntity> obj) {
+        return TypeIds.getTileTypeId(obj);
+    }
+}
-- 
2.4.6.windows.1.812.gd1b00d3

