From 1e7bfca69b0e3112952308b2c3259aac42338139 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Mon, 27 Jul 2015 08:21:37 -0700
Subject: [PATCH] Add an option to make the DataWatcher non-locking

Millions of entity getters use the DataWatcher every tick, so it is a "hot spot".
Before this patch the data watcher used a TIntObjectHashMap<> and a ReadWriteLock. Read locking millions of time every tick was taking up a lot of time, and this patch adds an option to make the data watcher weakly consistent, and make entity getters a lot cheeper.
This patch also optimizes the DataWatcher value map hash code.

diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
index dec091e..6805431 100644
--- a/src/main/java/net/minecraft/server/DataWatcher.java
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -7,27 +7,87 @@ import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import net.techcable.tacospigot.ConcurrentIntObjectMap; // TacoSpigot
+import net.techcable.tacospigot.IntHashStrategy; // TacoSpigot
+import net.techcable.tacospigot.TacoSpigotConfig; // TacoSpigot
+
 import org.apache.commons.lang3.ObjectUtils;
 
+import gnu.trove.map.hash.TIntObjectHashMap; // TacoSpigot
+
 public class DataWatcher {
 
+    // TacoSpigot start - initialize variables based on weather weakly consistent
+    public static final ReadWriteLock NO_OP_RW_LOCK = new ReadWriteLock() {
+
+        @Override
+        public Lock readLock() {
+            return NO_OP_LOCK;
+        }
+
+        @Override
+        public Lock writeLock() {
+            return NO_OP_LOCK;
+        }
+    };
+
+    public static final Lock NO_OP_LOCK = new Lock() {
+
+        @Override
+        public void lock() {}
+
+        @Override
+        public void lockInterruptibly() throws InterruptedException {}
+
+        @Override
+        public boolean tryLock() {
+            return true; // Make them think they are safe >:)
+        }
+
+        @Override
+        public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+            return true; // Make them think they are safe >:)
+        }
+
+        @Override
+        public void unlock() {}
+
+        @Override
+        public Condition newCondition() {
+            throw new UnsupportedOperationException("Techcable is lazy with his no-ops");
+        }
+    };
+
+    public DataWatcher(Entity entity) {
+        this.a = entity;
+        if (TacoSpigotConfig.dataWatcherWeaklyConsistent) {
+            dataValues = new ConcurrentIntObjectMap<WatchableObject>(10, 0.5f, 16, new DataWatcherHashStrategy());
+            f = NO_OP_RW_LOCK; // Plugins assume they can lock, so we have to null op it
+        } else {
+            dataValues = new TIntObjectHashMap<WatchableObject>(10, 0.05f);
+            f = new ReentrantReadWriteLock();
+        }
+        d = gnu.trove.TDecorators.wrap( dataValues );
+    }
+    // TacoSpigot end
+
     private final Entity a;
     private boolean b = true;
     // Spigot Start
     private static final gnu.trove.map.TObjectIntMap classToId = new gnu.trove.map.hash.TObjectIntHashMap( 10, 0.5f, -1 );
-    private final gnu.trove.map.TIntObjectMap dataValues = new gnu.trove.map.hash.TIntObjectHashMap( 10, 0.5f, -1 );
+    private final gnu.trove.map.TIntObjectMap<WatchableObject> dataValues; // TacoSpigot - init in constructor
     // These exist as an attempt at backwards compatability for (broken) NMS plugins
     private static final Map<Class<?>, Integer> c = gnu.trove.TDecorators.wrap( classToId );
-    private final Map<Integer, DataWatcher.WatchableObject> d = gnu.trove.TDecorators.wrap( dataValues );
-    // Spigot End
+    private final Map<Integer, DataWatcher.WatchableObject> d; // TacoSpigot - init in constructor so the compiler doesn't complain
+    // Spigot
     private boolean e;
-    private ReadWriteLock f = new ReentrantReadWriteLock();
-
-    public DataWatcher(Entity entity) {
-        this.a = entity;
-    }
+    private ReadWriteLock f; // TacoSpigot - add an option to make DataWatcher non-locking
 
     public <T> void a(int i, T t0) {
         int integer = classToId.get(t0.getClass()); // Spigot
@@ -384,4 +444,17 @@ public class DataWatcher {
             this.d = flag;
         }
     }
+
+    // TacoSpigot start
+    public static final int MAX_DATAWATCHER_INDEX = 22; // wiki.vg
+    /**
+     * Since datawatchers only have a set range of values, we can optimize the hashing strategy to eliminate collisions
+     */
+    public static class DataWatcherHashStrategy implements IntHashStrategy {
+
+        @Override
+        public int hash(int i) {
+            return i * (Integer.MAX_VALUE / MAX_DATAWATCHER_INDEX);
+        }
+    }
 }
diff --git a/src/main/java/net/techcable/tacospigot/ConcurrentIntObjectMap.java b/src/main/java/net/techcable/tacospigot/ConcurrentIntObjectMap.java
new file mode 100644
index 0000000..dd600b6
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/ConcurrentIntObjectMap.java
@@ -0,0 +1,1405 @@
+/*
+* Written by Doug Lea with assistance from members of JCP JSR-166
+* Expert Group and released to the public domain, as explained at
+* http://creativecommons.org/licenses/publicdomain
+*/
+
+package net.techcable.tacospigot;
+
+import java.io.Serializable;
+import java.util.AbstractCollection;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
+
+
+import net.techcable.tacospigot.IntHashStrategy.DefaultIntHashStrategy;
+
+import com.google.common.base.Preconditions;
+
+import gnu.trove.TIntCollection;
+import gnu.trove.function.TObjectFunction;
+import gnu.trove.iterator.TIntIterator;
+import gnu.trove.iterator.TIntObjectIterator;
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.procedure.TIntObjectProcedure;
+import gnu.trove.procedure.TIntProcedure;
+import gnu.trove.procedure.TObjectProcedure;
+import gnu.trove.set.TIntSet;
+import gnu.trove.set.hash.TIntHashSet;
+
+/**
+ * A weakly-consistent mapping of integers to objects with similar performance characteristics to {@link java.util.concurrent.ConcurrentHashMap}
+ * <p>
+ * Reading incurs no locking, but is not guaranteed to show the latest value from the write
+ * Once the write has completed, further reads will return the new value
+ * </p>
+ * Can have a custom integer hasing algorithim
+ *
+ * @author Doug Lea
+ * @author Techcable
+ * @param <V> the type of objects in the map
+ */
+public class ConcurrentIntObjectMap<V> implements TIntObjectMap<V> {
+    private final IntHashStrategy strategy;
+
+    /*
+     * The basic strategy is to subdivide the table among Segments,
+     * each of which itself is a concurrently readable hash table.
+     */
+
+    /* ---------------- Constants -------------- */
+
+    /**
+     * The default initial capacity for this table,
+     * used when not otherwise specified in a constructor.
+     */
+    static final int DEFAULT_INITIAL_CAPACITY = 16;
+
+    /**
+     * The default load factor for this table, used when not
+     * otherwise specified in a constructor.
+     */
+    static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    /**
+     * The default concurrency level for this table, used when not
+     * otherwise specified in a constructor.
+     */
+    static final int DEFAULT_CONCURRENCY_LEVEL = 16;
+
+    /**
+     * The maximum capacity, used if a higher value is implicitly
+     * specified by either of the constructors with arguments.  MUST
+     * be a power of two <= 1<<30 to ensure that entries are indexable
+     * using ints.
+     */
+    static final int MAXIMUM_CAPACITY = 1 << 30;
+
+    /**
+     * The maximum number of segments to allow; used to bound
+     * constructor arguments.
+     */
+    static final int MAX_SEGMENTS = 1 << 16; // slightly conservative
+
+    /**
+     * Number of unsynchronized retries in size and containsValue
+     * methods before resorting to locking. This is used to avoid
+     * unbounded retries if tables undergo continuous modification
+     * which would make it impossible to obtain an accurate result.
+     */
+    static final int RETRIES_BEFORE_LOCK = 2;
+
+    /* ---------------- Fields -------------- */
+
+    /**
+     * Mask value for indexing into segments. The upper bits of a
+     * key's hash code are used to choose the segment.
+     */
+    final int segmentMask;
+
+    /**
+     * Shift value for indexing within segments.
+     */
+    final int segmentShift;
+
+    /**
+     * The segments, each of which is a specialized hash table
+     */
+    final Segment<V>[] segments;
+
+    transient TIntSet keySet;
+    transient Set<IntEntry<V>> entrySet;
+    transient Collection<V> values;
+
+    /* ---------------- Small Utilities -------------- */
+
+    /**
+     * Applies a supplemental hash function to a given hashCode, which
+     * defends against poor quality hash functions.  This is critical
+     * because ConcurrentHashMap uses power-of-two length hash tables,
+     * that otherwise encounter collisions for hashCodes that do not
+     * differ in lower or upper bits.
+     */
+    private static int supplementHash(int h) {
+        // Spread bits to regularize both segment and index locations,
+        // using variant of single-word Wang/Jenkins hash.
+        h += (h << 15) ^ 0xffffcd7d;
+        h ^= (h >>> 10);
+        h += (h << 3);
+        h ^= (h >>> 6);
+        h += (h << 2) + (h << 14);
+        return h ^ (h >>> 16);
+    }
+
+    /**
+     * Returns the segment that should be used for key with given hash
+     *
+     * @param hash the hash code for the key
+     *
+     * @return the segment
+     */
+    final Segment<V> segmentFor(int hash) {
+        return segments[(hash >>> segmentShift) & segmentMask];
+    }
+
+    /* ---------------- Inner Classes -------------- */
+
+    /**
+     * ConcurrentHashMap list entry. Note that this is never exported
+     * out as a user-visible Map.Entry.
+     * <p/>
+     * Because the value field is volatile, not final, it is legal wrt
+     * the Java Memory Model for an unsynchronized reader to see null
+     * instead of initial value when read via a data race.  Although a
+     * reordering leading to this is not likely to ever actually
+     * occur, the Segment.readValueUnderLock method is used as a
+     * backup in case a null (pre-initialized) value is ever seen in
+     * an unsynchronized access method.
+     */
+    static final class HashEntry<V> {
+
+        final int key;
+        final int hash;
+        volatile V value;
+        final HashEntry<V> next;
+
+        HashEntry(int key, int hash, HashEntry<V> next, V value) {
+            this.key = key;
+            this.hash = hash;
+            this.next = next;
+            this.value = value;
+        }
+
+        @SuppressWarnings("unchecked")
+        static final <V> HashEntry<V>[] newArray(int i) {
+            return new HashEntry[i];
+        }
+    }
+
+    /**
+     * Segments are specialized versions of hash tables.  This
+     * subclasses from ReentrantLock opportunistically, just to
+     * simplify some locking and avoid separate construction.
+     */
+    static final class Segment<V> extends ReentrantLock implements Serializable {
+        /*
+         * Segments maintain a table of entry lists that are ALWAYS
+         * kept in a consistent state, so can be read without locking.
+         * Next fields of nodes are immutable (final).  All list
+         * additions are performed at the front of each bin. This
+         * makes it easy to check changes, and also fast to traverse.
+         * When nodes would otherwise be changed, new nodes are
+         * created to replace them. This works well for hash tables
+         * since the bin lists tend to be short. (The average length
+         * is less than two for the default load factor threshold.)
+         *
+         * Read operations can thus proceed without locking, but rely
+         * on selected uses of volatiles to ensure that completed
+         * write operations performed by other threads are
+         * noticed. For most purposes, the "count" field, tracking the
+         * number of elements, serves as that volatile variable
+         * ensuring visibility.  This is convenient because this field
+         * needs to be read in many read operations anyway:
+         *
+         *   - All (unsynchronized) read operations must first read the
+         *     "count" field, and should not look at table entries if
+         *     it is 0.
+         *
+         *   - All (synchronized) write operations should write to
+         *     the "count" field after structurally changing any bin.
+         *     The operations must not take any action that could even
+         *     momentarily cause a concurrent read operation to see
+         *     inconsistent data. This is made easier by the nature of
+         *     the read operations in Map. For example, no operation
+         *     can reveal that the table has grown but the threshold
+         *     has not yet been updated, so there are no atomicity
+         *     requirements for this with respect to reads.
+         *
+         * As a guide, all critical volatile reads and writes to the
+         * count field are marked in code comments.
+         */
+
+        private static final long serialVersionUID = 2249069246763182397L;
+
+        /**
+         * The number of elements in this segment's region.
+         */
+        transient volatile int count;
+
+        /**
+         * Number of updates that alter the size of the table. This is
+         * used during bulk-read methods to make sure they see a
+         * consistent snapshot: If modCounts change during a traversal
+         * of segments computing size or checking containsValue, then
+         * we might have an inconsistent view of state so (usually)
+         * must retry.
+         */
+        transient int modCount;
+
+        /**
+         * The table is rehashed when its size exceeds this threshold.
+         * (The value of this field is always <tt>(int)(capacity *
+         * loadFactor)</tt>.)
+         */
+        transient int threshold;
+
+        /**
+         * The per-segment table.
+         */
+        transient volatile HashEntry<V>[] table;
+
+        /**
+         * The load factor for the hash table.  Even though this value
+         * is same for all segments, it is replicated to avoid needing
+         * links to outer object.
+         */
+        final float loadFactor;
+
+        Segment(int initialCapacity, float lf) {
+            loadFactor = lf;
+            setTable(HashEntry.<V>newArray(initialCapacity));
+        }
+
+        @SuppressWarnings("unchecked")
+        static final <V> Segment<V>[] newArray(int i) {
+            return new Segment[i];
+        }
+
+        /**
+         * Sets table to new HashEntry array.
+         * Call only while holding lock or in constructor.
+         */
+        void setTable(HashEntry<V>[] newTable) {
+            threshold = (int) (newTable.length * loadFactor);
+            table = newTable;
+        }
+
+        /**
+         * Returns properly casted first entry of bin for given hash.
+         */
+        HashEntry<V> getFirst(int hash) {
+            HashEntry<V>[] tab = table;
+            return tab[hash & (tab.length - 1)];
+        }
+
+        /**
+         * Reads value field of an entry under lock. Called if value
+         * field ever appears to be null. This is possible only if a
+         * compiler happens to reorder a HashEntry initialization with
+         * its table assignment, which is legal under memory model
+         * but is not known to ever occur.
+         */
+        V readValueUnderLock(HashEntry<V> e) {
+            lock();
+            try {
+                return e.value;
+            } finally {
+                unlock();
+            }
+        }
+
+        /* Specialized implementations of map methods */
+
+        V get(int key, int hash) {
+            if (count != 0) { // read-volatile
+                HashEntry<V> e = getFirst(hash);
+                while (e != null) {
+                    if (key == e.key) {
+                        V v = e.value;
+                        if (v != null) return v;
+                        return readValueUnderLock(e); // recheck
+                    }
+                    e = e.next;
+                }
+            }
+            return null;
+        }
+
+        boolean containsKey(int key, int hash) {
+            if (count != 0) { // read-volatile
+                HashEntry<V> e = getFirst(hash);
+                while (e != null) {
+                    if (key == e.key) return true;
+                    e = e.next;
+                }
+            }
+            return false;
+        }
+
+        boolean containsValue(Object value) {
+            if (count != 0) { // read-volatile
+                HashEntry<V>[] tab = table;
+                int len = tab.length;
+                for (int i = 0; i < len; i++) {
+                    for (HashEntry<V> e = tab[i]; e != null; e = e.next) {
+                        V v = e.value;
+                        if (v == null) // recheck
+                            v = readValueUnderLock(e);
+                        if (value.equals(v)) return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        boolean replace(int key, int hash, V oldValue, V newValue) {
+            lock();
+            try {
+                HashEntry<V> e = getFirst(hash);
+                while (e != null && (key != e.key)) e = e.next;
+
+                boolean replaced = false;
+                if (e != null && oldValue.equals(e.value)) {
+                    replaced = true;
+                    e.value = newValue;
+                }
+                return replaced;
+            } finally {
+                unlock();
+            }
+        }
+
+        V replace(int key, int hash, V newValue) {
+            lock();
+            try {
+                HashEntry<V> e = getFirst(hash);
+                while (e != null && (key != e.key)) e = e.next;
+
+                V oldValue = null;
+                if (e != null) {
+                    oldValue = e.value;
+                    e.value = newValue;
+                }
+                return oldValue;
+            } finally {
+                unlock();
+            }
+        }
+
+
+        V put(int key, int hash, V value, boolean onlyIfAbsent) {
+            lock();
+            try {
+                int c = count;
+                if (c++ > threshold) // ensure capacity
+                    rehash();
+                HashEntry<V>[] tab = table;
+                int index = hash & (tab.length - 1);
+                HashEntry<V> first = tab[index];
+                HashEntry<V> e = first;
+                while (e != null && (key != e.key)) e = e.next;
+
+                V oldValue;
+                if (e != null) {
+                    oldValue = e.value;
+                    if (!onlyIfAbsent) e.value = value;
+                } else {
+                    oldValue = null;
+                    ++modCount;
+                    tab[index] = new HashEntry<V>(key, hash, first, value);
+                    count = c; // write-volatile
+                }
+                return oldValue;
+            } finally {
+                unlock();
+            }
+        }
+
+        void rehash() {
+            HashEntry<V>[] oldTable = table;
+            int oldCapacity = oldTable.length;
+            if (oldCapacity >= MAXIMUM_CAPACITY) return;
+
+            /*
+             * Reclassify nodes in each list to new Map.  Because we are
+             * using power-of-two expansion, the elements from each bin
+             * must either stay at same index, or move with a power of two
+             * offset. We eliminate unnecessary node creation by catching
+             * cases where old nodes can be reused because their next
+             * fields won't change. Statistically, at the default
+             * threshold, only about one-sixth of them need cloning when
+             * a table doubles. The nodes they replace will be garbage
+             * collectable as soon as they are no longer referenced by any
+             * reader thread that may be in the midst of traversing table
+             * right now.
+             */
+
+            HashEntry<V>[] newTable = HashEntry.newArray(oldCapacity << 1);
+            threshold = (int) (newTable.length * loadFactor);
+            int sizeMask = newTable.length - 1;
+            for (int i = 0; i < oldCapacity; i++) {
+                // We need to guarantee that any existing reads of old Map can
+                //  proceed. So we cannot yet null out each bin.
+                HashEntry<V> e = oldTable[i];
+
+                if (e != null) {
+                    HashEntry<V> next = e.next;
+                    int idx = e.hash & sizeMask;
+
+                    //  Single node on list
+                    if (next == null) newTable[idx] = e;
+
+                    else {
+                        // Reuse trailing consecutive sequence at same slot
+                        HashEntry<V> lastRun = e;
+                        int lastIdx = idx;
+                        for (HashEntry<V> last = next; last != null; last = last.next) {
+                            int k = last.hash & sizeMask;
+                            if (k != lastIdx) {
+                                lastIdx = k;
+                                lastRun = last;
+                            }
+                        }
+                        newTable[lastIdx] = lastRun;
+
+                        // Clone all remaining nodes
+                        for (HashEntry<V> p = e; p != lastRun; p = p.next) {
+                            int k = p.hash & sizeMask;
+                            HashEntry<V> n = newTable[k];
+                            newTable[k] = new HashEntry<V>(p.key, p.hash, n, p.value);
+                        }
+                    }
+                }
+            }
+            table = newTable;
+        }
+
+        /**
+         * Remove; match on key only if value null, else match both.
+         */
+        V remove(int key, int hash, Object value) {
+            lock();
+            try {
+                int c = count - 1;
+                HashEntry<V>[] tab = table;
+                int index = hash & (tab.length - 1);
+                HashEntry<V> first = tab[index];
+                HashEntry<V> e = first;
+                while (e != null && (key != e.key)) e = e.next;
+
+                V oldValue = null;
+                if (e != null) {
+                    V v = e.value;
+                    if (value == null || value.equals(v)) {
+                        oldValue = v;
+                        // All entries following removed node can stay
+                        // in list, but all preceding ones need to be
+                        // cloned.
+                        ++modCount;
+                        HashEntry<V> newFirst = e.next;
+                        for (HashEntry<V> p = first; p != e; p = p.next) {
+                            newFirst = new HashEntry<V>(p.key, p.hash, newFirst, p.value);
+                        }
+                        tab[index] = newFirst;
+                        count = c; // write-volatile
+                    }
+                }
+                return oldValue;
+            } finally {
+                unlock();
+            }
+        }
+
+        void clear() {
+            if (count != 0) {
+                lock();
+                try {
+                    HashEntry<V>[] tab = table;
+                    for (int i = 0; i < tab.length; i++) {
+                        tab[i] = null;
+                    }
+                    ++modCount;
+                    count = 0; // write-volatile
+                } finally {
+                    unlock();
+                }
+            }
+        }
+    }
+
+
+
+    /* ---------------- Public operations -------------- */
+
+    /**
+     * Creates a new, empty map with the specified initial
+     * capacity, load factor and concurrency level.
+     *
+     * @param initialCapacity the initial capacity. The implementation
+     * performs internal sizing to accommodate this many elements.
+     * @param loadFactor the load factor threshold, used to control resizing.
+     * Resizing may be performed when the average number of elements per
+     * bin exceeds this threshold.
+     * @param concurrencyLevel the estimated number of concurrently
+     * updating threads. The implementation performs internal sizing
+     * to try to accommodate this many threads.
+     *
+     * @throws IllegalArgumentException if the initial capacity is
+     * negative or the load factor or concurrencyLevel are
+     * nonpositive.
+     */
+    public ConcurrentIntObjectMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
+        this(initialCapacity, loadFactor, concurrencyLevel, DefaultIntHashStrategy.getInstance());
+    }
+
+    /**
+     * Creates a new, empty map with the specified initial
+     * capacity, load factor, concurrency level and hashing strategy.
+     *
+     * @param initialCapacity the initial capacity. The implementation
+     * performs internal sizing to accommodate this many elements.
+     * @param loadFactor the load factor threshold, used to control resizing.
+     * Resizing may be performed when the average number of elements per
+     * bin exceeds this threshold.
+     * @param concurrencyLevel the estimated number of concurrently
+     * updating threads. The implementation performs internal sizing
+     * to try to accommodate this many threads.
+     * @param strategy the hashing strategy
+     *
+     * @throws IllegalArgumentException if the initial capacity is
+     * negative or the load factor or concurrencyLevel are
+     * nonpositive.
+     */
+    public ConcurrentIntObjectMap(int initialCapacity, float loadFactor, int concurrencyLevel, final IntHashStrategy strategy) {
+        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0) throw new IllegalArgumentException();
+        this.strategy = new IntHashStrategy() {
+
+            @Override
+            public int hash(int i) {
+                int hash = strategy.hash(i);
+                hash = supplementHash(hash);
+                return hash;
+            }
+        };
+
+        if (concurrencyLevel > MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS;
+
+        // Find power-of-two sizes best matching arguments
+        int sshift = 0;
+        int ssize = 1;
+        while (ssize < concurrencyLevel) {
+            ++sshift;
+            ssize <<= 1;
+        }
+        segmentShift = 32 - sshift;
+        segmentMask = ssize - 1;
+        this.segments = Segment.newArray(ssize);
+
+        if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;
+        int c = initialCapacity / ssize;
+        if (c * ssize < initialCapacity) ++c;
+        int cap = 1;
+        while (cap < c) cap <<= 1;
+
+        for (int i = 0; i < this.segments.length; ++i) {
+            this.segments[i] = new Segment<V>(cap, loadFactor);
+        }
+    }
+
+    /**
+     * Creates a new, empty map with the specified initial capacity
+     * and load factor and with the default concurrencyLevel (16).
+     *
+     * @param initialCapacity The implementation performs internal
+     * sizing to accommodate this many elements.
+     * @param loadFactor the load factor threshold, used to control resizing.
+     * Resizing may be performed when the average number of elements per
+     * bin exceeds this threshold.
+     *
+     * @throws IllegalArgumentException if the initial capacity of
+     * elements is negative or the load factor is nonpositive
+     * @since 1.6
+     */
+    public ConcurrentIntObjectMap(int initialCapacity, float loadFactor) {
+        this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);
+    }
+
+    /**
+     * Creates a new, empty map with the specified initial capacity,
+     * and with default load factor (0.75) and concurrencyLevel (16).
+     *
+     * @param initialCapacity the initial capacity. The implementation
+     * performs internal sizing to accommodate this many elements.
+     *
+     * @throws IllegalArgumentException if the initial capacity of
+     * elements is negative.
+     */
+    public ConcurrentIntObjectMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
+    }
+
+    /**
+     * Creates a new, empty map with a default initial capacity (16),
+     * load factor (0.75) and concurrencyLevel (16).
+     */
+    public ConcurrentIntObjectMap() {
+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
+    }
+
+    /**
+     * Creates a new map with the same mappings as the given map.
+     * The map is created with a capacity of 1.5 times the number
+     * of mappings in the given map or 16 (whichever is greater),
+     * and a default load factor (0.75) and concurrencyLevel (16).
+     *
+     * @param m the map
+     */
+    public ConcurrentIntObjectMap(TIntObjectMap<V> m) {
+        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
+        putAll(m);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this map contains no key-value mappings.
+     *
+     * @return <tt>true</tt> if this map contains no key-value mappings
+     */
+    @Override
+    public boolean isEmpty() {
+        final Segment<V>[] segments = this.segments;
+        /*
+         * We keep track of per-segment modCounts to avoid ABA
+         * problems in which an element in one segment was added and
+         * in another removed during traversal, in which case the
+         * table was never actually empty at any point. Note the
+         * similar use of modCounts in the size() and containsValue()
+         * methods, which are the only other methods also susceptible
+         * to ABA problems.
+         */
+        int[] mc = new int[segments.length];
+        int mcsum = 0;
+        for (int i = 0; i < segments.length; ++i) {
+            if (segments[i].count != 0) return false;
+            else mcsum += mc[i] = segments[i].modCount;
+        }
+        // If mcsum happens to be zero, then we know we got a snapshot
+        // before any modifications at all were made.  This is
+        // probably common enough to bother tracking.
+        if (mcsum != 0) {
+            for (int i = 0; i < segments.length; ++i) {
+                if (segments[i].count != 0 || mc[i] != segments[i].modCount) return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns the number of key-value mappings in this map.  If the
+     * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns
+     * <tt>Integer.MAX_VALUE</tt>.
+     *
+     * @return the number of key-value mappings in this map
+     */
+    public int size() {
+        final Segment<V>[] segments = this.segments;
+        long sum = 0;
+        long check = 0;
+        int[] mc = new int[segments.length];
+        // Try a few times to get accurate count. On failure due to
+        // continuous async changes in table, resort to locking.
+        for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {
+            check = 0;
+            sum = 0;
+            int mcsum = 0;
+            for (int i = 0; i < segments.length; ++i) {
+                sum += segments[i].count;
+                mcsum += mc[i] = segments[i].modCount;
+            }
+            if (mcsum != 0) {
+                for (int i = 0; i < segments.length; ++i) {
+                    check += segments[i].count;
+                    if (mc[i] != segments[i].modCount) {
+                        check = -1; // force retry
+                        break;
+                    }
+                }
+            }
+            if (check == sum) break;
+        }
+        if (check != sum) { // Resort to locking all segments
+            sum = 0;
+            for (int i = 0; i < segments.length; ++i) {
+                segments[i].lock();
+            }
+            for (int i = 0; i < segments.length; ++i) {
+                sum += segments[i].count;
+            }
+            for (int i = 0; i < segments.length; ++i) {
+                segments[i].unlock();
+            }
+        }
+        if (sum > Integer.MAX_VALUE) return Integer.MAX_VALUE;
+        else return (int) sum;
+    }
+
+    /**
+     * Returns the value to which the specified key is mapped,
+     * or {@code null} if this map contains no mapping for the key.
+     * <p/>
+     * <p>More formally, if this map contains a mapping from a key
+     * {@code k} to a value {@code v} such that {@code key.equals(k)},
+     * then this method returns {@code v}; otherwise it returns
+     * {@code null}.  (There can be at most one such mapping.)
+     *
+     * @throws NullPointerException if the specified key is null
+     */
+    @Override
+    public V get(int key) {
+        int hash = strategy.hash(key);
+        return segmentFor(hash).get(key, hash);
+    }
+
+    /**
+     * Tests if the specified object is a key in this table.
+     *
+     * @param key possible key
+     *
+     * @return <tt>true</tt> if and only if the specified object
+     * is a key in this table, as determined by the
+     * <tt>equals</tt> method; <tt>false</tt> otherwise.
+     *
+     * @throws NullPointerException if the specified key is null
+     */
+    public boolean containsKey(int key) {
+        int hash = strategy.hash(key);
+        return segmentFor(hash).containsKey(key, hash);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this map maps one or more keys to the
+     * specified value. Note: This method requires a full internal
+     * traversal of the hash table, and so is much slower than
+     * method <tt>containsKey</tt>.
+     *
+     * @param value value whose presence in this map is to be tested
+     *
+     * @return <tt>true</tt> if this map maps one or more keys to the
+     * specified value
+     *
+     * @throws NullPointerException if the specified value is null
+     */
+    public boolean containsValue(Object value) {
+        if (value == null) throw new NullPointerException();
+
+        // See explanation of modCount use above
+
+        final Segment<V>[] segments = this.segments;
+        int[] mc = new int[segments.length];
+
+        // Try a few times without locking
+        for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {
+            int sum = 0;
+            int mcsum = 0;
+            for (int i = 0; i < segments.length; ++i) {
+                int c = segments[i].count;
+                mcsum += mc[i] = segments[i].modCount;
+                if (segments[i].containsValue(value)) return true;
+            }
+            boolean cleanSweep = true;
+            if (mcsum != 0) {
+                for (int i = 0; i < segments.length; ++i) {
+                    int c = segments[i].count;
+                    if (mc[i] != segments[i].modCount) {
+                        cleanSweep = false;
+                        break;
+                    }
+                }
+            }
+            if (cleanSweep) return false;
+        }
+        // Resort to locking all segments
+        for (int i = 0; i < segments.length; ++i) {
+            segments[i].lock();
+        }
+        boolean found = false;
+        try {
+            for (int i = 0; i < segments.length; ++i) {
+                if (segments[i].containsValue(value)) {
+                    found = true;
+                    break;
+                }
+            }
+        } finally {
+            for (int i = 0; i < segments.length; ++i) {
+                segments[i].unlock();
+            }
+        }
+        return found;
+    }
+
+    /**
+     * Returns an enumeration of the values in this table.
+     *
+     * @return an enumeration of the values in this table
+     *
+     * @see #values()
+     */
+    public Enumeration<V> elements() {
+        return new ValueIterator();
+    }
+
+    /* ---------------- Iterator Support -------------- */
+
+    abstract class HashIterator {
+
+        int nextSegmentIndex;
+        int nextTableIndex;
+        HashEntry<V>[] currentTable;
+        HashEntry<V> nextEntry;
+        HashEntry<V> lastReturned;
+
+        HashIterator() {
+            nextSegmentIndex = segments.length - 1;
+            nextTableIndex = -1;
+            advance0();
+        }
+
+        public boolean hasMoreElements() {
+            return hasNext();
+        }
+
+        final void advance0() {
+            if (nextEntry != null && (nextEntry = nextEntry.next) != null) return;
+
+            while (nextTableIndex >= 0) {
+                if ((nextEntry = currentTable[nextTableIndex--]) != null) return;
+            }
+
+            while (nextSegmentIndex >= 0) {
+                Segment<V> seg = segments[nextSegmentIndex--];
+                if (seg.count != 0) {
+                    currentTable = seg.table;
+                    for (int j = currentTable.length - 1; j >= 0; --j) {
+                        if ((nextEntry = currentTable[j]) != null) {
+                            nextTableIndex = j - 1;
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+
+        public boolean hasNext() {
+            return nextEntry != null;
+        }
+
+        HashEntry<V> nextEntry() {
+            if (nextEntry == null) throw new NoSuchElementException();
+            lastReturned = nextEntry;
+            advance0();
+            return lastReturned;
+        }
+
+        public void remove() {
+            if (lastReturned == null) throw new IllegalStateException();
+            ConcurrentIntObjectMap.this.remove(lastReturned.key);
+            lastReturned = null;
+        }
+    }
+
+    final class KeyIterator extends HashIterator implements TIntIterator {
+
+        public int next() {
+            return super.nextEntry().key;
+        }
+
+        public int nextElement() {
+            return super.nextEntry().key;
+        }
+    }
+
+    final class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> {
+
+        public V next() {
+            return super.nextEntry().value;
+        }
+
+        public V nextElement() {
+            return super.nextEntry().value;
+        }
+    }
+
+    /**
+     * Custom Entry class used by EntryIterator.next(), that relays
+     * setValue changes to the underlying map.
+     */
+    final class WriteThroughEntry implements IntEntry<V> {
+
+        private final int key;
+        private V value;
+
+        WriteThroughEntry(int k, V value) {
+            this.key = k;
+            this.value = value;
+        }
+
+        /**
+         * Set our entry's value and write through to the map. The
+         * value to return is somewhat arbitrary here. Since a
+         * WriteThroughEntry does not necessarily track asynchronous
+         * changes, the most recent "previous" value could be
+         * different from what we return (or could even have been
+         * removed in which case the put will re-establish). We do not
+         * and cannot guarantee more.
+         */
+        public V setValue(V value) {
+            if (value == null) throw new NullPointerException();
+            V old = value;
+            this.value = value;
+            ConcurrentIntObjectMap.this.put(getKey(), value);
+            return old;
+        }
+
+        @Override
+        public int getKey() {
+            return key;
+        }
+
+        @Override
+        public V getValue() {
+            return value;
+        }
+
+        @Override
+        public int hashCode() {
+            int prime = 31;
+            int result = 1;
+            result = prime * result + getKey();
+            result = prime * result + getValue().hashCode();
+            return result;
+        }
+    }
+
+    final class EntryIterator extends HashIterator implements Iterator<IntEntry<V>> {
+
+        public IntEntry<V> next() {
+            HashEntry<V> e = super.nextEntry();
+            return new WriteThroughEntry(e.key, e.value);
+        }
+    }
+
+    final class KeySet implements TIntSet {
+
+        public TIntIterator iterator() {
+            return new KeyIterator();
+        }
+
+        @Override
+        public int[] toArray() {
+            return toArray(new int[size()]);
+
+        }
+
+        @Override
+        public int[] toArray(int[] array) {
+            TIntIterator iterator = iterator();
+            int i = 0;
+            while (iterator.hasNext()) {
+                if (i <= array.length) array = Arrays.copyOf(array, i + 1 + 5);
+                array[i] = iterator.next();
+                i++;
+            }
+            return array;
+        }
+
+        @Override
+        public boolean add(int i) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> collection) {
+            for (Object o : collection) {
+                if (o instanceof Integer) {
+                    if (!contains((Integer) o)) return false;
+                }
+            }
+            return true;
+        }
+
+        @Override
+        public boolean containsAll(TIntCollection tIntCollection) {
+            TIntIterator iterator = tIntCollection.iterator();
+            while (iterator.hasNext()) {
+                int i = iterator.next();
+                if (!contains(i)) return false;
+            }
+            return true;
+        }
+
+        @Override
+        public boolean containsAll(int[] ints) {
+            for (int i : ints) {
+                if (!contains(i)) return false;
+            }
+            return true;
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> collection) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean addAll(TIntCollection tIntCollection) {
+            return false;
+        }
+
+        @Override
+        public boolean addAll(int[] ints) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> collection) {
+            TIntIterator iterator = iterator();
+            boolean modified = false;
+            while (iterator.hasNext()) {
+                int i = iterator.next();
+                if (!collection.contains(i)) {
+                    modified = remove(i) || modified;
+                }
+            }
+            return modified;
+        }
+
+        @Override
+        public boolean retainAll(TIntCollection tIntCollection) {
+            TIntIterator iterator = iterator();
+            boolean modified = false;
+            while (iterator.hasNext()) {
+                int i = iterator.next();
+                if (!tIntCollection.contains(i)) {
+                    modified = remove(i) || modified;
+                }
+            }
+            return modified;
+        }
+
+        @Override
+        public boolean retainAll(int[] ints) {
+            return retainAll(new TIntHashSet(ints));
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> collection) {
+            boolean modified = false;
+            for (Object o : collection) {
+                if (o instanceof Integer) {
+                    modified = remove((Integer) o) || modified;
+                }
+            }
+            return modified;
+        }
+
+        @Override
+        public boolean removeAll(TIntCollection tIntCollection) {
+            TIntIterator iterator = tIntCollection.iterator();
+            boolean modified = false;
+            while (iterator.hasNext()) {
+                modified = remove(iterator.next()) || modified;
+            }
+            return modified;
+        }
+
+        @Override
+        public boolean removeAll(int[] ints) {
+            boolean modififed = false;
+            for (int i : ints) {
+                modififed = remove(i) || modififed;
+            }
+            return modififed;
+        }
+
+        @Override
+        public int getNoEntryValue() {
+            throw new UnsupportedClassVersionError("No no-entry-values");
+        }
+
+        public int size() {
+            return ConcurrentIntObjectMap.this.size();
+        }
+
+        public boolean isEmpty() {
+            return ConcurrentIntObjectMap.this.isEmpty();
+        }
+
+        public boolean contains(int i) {
+            return ConcurrentIntObjectMap.this.containsKey(i);
+        }
+
+        @Override
+        public boolean remove(int i) {
+            return ConcurrentIntObjectMap.this.remove(i) != null;
+        }
+
+        public void clear() {
+            ConcurrentIntObjectMap.this.clear();
+        }
+
+        @Override
+        public boolean forEach(TIntProcedure tIntProcedure) {
+            TIntIterator iterator = iterator();
+            while (iterator.hasNext()) {
+                int i = iterator.next();
+                if (!tIntProcedure.execute(i)) return false;
+            }
+            return true;
+        }
+    }
+
+    final class Values extends AbstractCollection<V> {
+
+        public Iterator<V> iterator() {
+            return new ValueIterator();
+        }
+
+        public int size() {
+            return ConcurrentIntObjectMap.this.size();
+        }
+
+        public boolean isEmpty() {
+            return ConcurrentIntObjectMap.this.isEmpty();
+        }
+
+        public boolean contains(Object o) {
+            return ConcurrentIntObjectMap.this.containsValue(o);
+        }
+
+        public void clear() {
+            ConcurrentIntObjectMap.this.clear();
+        }
+    }
+
+    final class EntrySet extends AbstractSet<IntEntry<V>> {
+
+        public Iterator<IntEntry<V>> iterator() {
+            return new EntryIterator();
+        }
+
+        public boolean contains(Object o) {
+            if (!(o instanceof IntEntry)) return false;
+            IntEntry<?> e = (IntEntry<?>) o;
+            V v = ConcurrentIntObjectMap.this.get(e.getKey());
+            return v != null && v.equals(e.getValue());
+        }
+
+        public boolean remove(Object o) {
+            if (!(o instanceof Map.Entry)) return false;
+            IntEntry<?> e = (IntEntry<?>) o;
+            return ConcurrentIntObjectMap.this.remove(e.getKey(), (V) e.getValue()) != null;
+        }
+
+        public int size() {
+            return ConcurrentIntObjectMap.this.size();
+        }
+
+        public boolean isEmpty() {
+            return ConcurrentIntObjectMap.this.isEmpty();
+        }
+
+        public void clear() {
+            ConcurrentIntObjectMap.this.clear();
+        }
+    }
+
+    //
+    // Techcable's Code
+    //
+
+
+    @Override
+    public int getNoEntryKey() {
+        throw new UnsupportedOperationException("We have no \"no entry key\"");
+    }
+
+    @Override
+    public V put(int key, V value) {
+        Preconditions.checkNotNull(value);
+        int hash = strategy.hash(key);
+        return segmentFor(hash).put(key, hash, value, false);
+    }
+
+    @Override
+    public V putIfAbsent(int key, V value) {
+        Preconditions.checkNotNull(value);
+        int hash = strategy.hash(key);
+        return segmentFor(hash).put(key, hash, value, true);
+    }
+
+    public V remove(int key, V value) {
+        Preconditions.checkNotNull(value);
+        int hash = strategy.hash(key);
+        return segmentFor(hash).remove(key, hash, value);
+    }
+
+    @Override
+    public V remove(int key) {
+        int hash = strategy.hash(key);
+        return segmentFor(key).remove(key, hash, null);
+    }
+
+    @Override
+    public void putAll(Map<? extends Integer, ? extends V> m) {
+        for (Map.Entry<? extends Integer, ? extends V> entry : m.entrySet()) {
+            put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    @Override
+    public void putAll(TIntObjectMap<? extends V> tIntObjectMap) {
+        tIntObjectMap.forEachEntry(new TIntObjectProcedure<V>() {
+
+            @Override
+            public boolean execute(int a, V b) {
+                put(a, b);
+                return true; // continue
+            }
+        });
+    }
+
+    @Override
+    public void clear() {
+        for (Segment segment : segments) {
+            segment.clear();
+        }
+    }
+
+    @Override
+    public TIntSet keySet() {
+        TIntSet keySet = this.keySet;
+        return keySet != null ? keySet : (this.keySet = new KeySet());
+    }
+
+    @Override
+    public int[] keys() {
+        return keySet().toArray();
+    }
+
+    @Override
+    public int[] keys(int[] ints) {
+        return keySet().toArray(ints);
+    }
+
+    @Override
+    public Collection<V> valueCollection() {
+        Collection<V> values = this.values;
+        return values != null ? values : (this.values = new Values());
+    }
+
+    @Override
+    public Object[] values() {
+        return valueCollection().toArray();
+    }
+
+    @Override
+    public V[] values(V[] vs) {
+        return valueCollection().toArray(vs);
+    }
+
+    @Override
+    public TIntObjectIterator<V> iterator() {
+        return new ConcurrentIntObjectMapIterator();
+    }
+
+    private class ConcurrentIntObjectMapIterator extends HashIterator implements TIntObjectIterator<V> {
+
+        @Override
+        public int key() {
+            Preconditions.checkState(entry != null, "advance() was not called");
+            return entry.key;
+        }
+
+        @Override
+        public V value() {
+            Preconditions.checkState(entry != null, "advance() was not called");
+            return entry.value;
+        }
+
+        @Override
+        public V setValue(V val) {
+            return ConcurrentIntObjectMap.this.put(key(), val);
+        }
+
+        private HashEntry<V> entry;
+
+        @Override
+        public void advance() {
+            entry = super.nextEntry;
+        }
+    }
+
+    @Override
+    public boolean forEachKey(TIntProcedure tIntProcedure) {
+        TIntIterator iterator = keySet().iterator();
+        while (iterator.hasNext()) {
+            int i = iterator.next();
+            if (!tIntProcedure.execute(i)) return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean forEachValue(TObjectProcedure<? super V> tObjectProcedure) {
+        Iterator<V> iterator = valueCollection().iterator();
+        while (iterator.hasNext()) {
+            V value = iterator.next();
+            if (!tObjectProcedure.execute(value)) return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean forEachEntry(TIntObjectProcedure<? super V> tIntObjectProcedure) {
+        TIntObjectIterator<V> iterator = iterator();
+        while (iterator.hasNext()) {
+            iterator.advance();
+            int key = iterator.key();
+            V value = iterator.value();
+            if (!tIntObjectProcedure.execute(key, value)) return false;
+        }
+        return true;
+    }
+
+    @Override
+    public void transformValues(TObjectFunction<V, V> tObjectFunction) {
+        TIntObjectIterator<V> iterator = iterator();
+        while (iterator.hasNext()) {
+            iterator.advance();
+            V oldValue = iterator.value();
+            V newValue = tObjectFunction.execute(oldValue);
+            iterator.setValue(newValue);
+        }
+    }
+
+    @Override
+    public boolean retainEntries(TIntObjectProcedure<? super V> tIntObjectProcedure) {
+        TIntObjectIterator<V> iterator = iterator();
+        boolean modified = false;
+        while (iterator.hasNext()) {
+            iterator.advance();
+            int key = iterator.key();
+            V value = iterator.value();
+            if (!tIntObjectProcedure.execute(key, value)) {
+                modified = this.remove(key) != null || modified;
+            }
+        }
+        return modified;
+    }
+
+    private interface IntEntry<V> {
+
+        public int getKey();
+
+        public V getValue();
+
+        public V setValue(V value);
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/IntHashStrategy.java b/src/main/java/net/techcable/tacospigot/IntHashStrategy.java
new file mode 100644
index 0000000..8c52bc1
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/IntHashStrategy.java
@@ -0,0 +1,19 @@
+package net.techcable.tacospigot;
+
+public interface IntHashStrategy {
+    public int hash(int i);
+
+    public static class DefaultIntHashStrategy implements IntHashStrategy {
+        private DefaultIntHashStrategy() {}
+
+        @Override
+        public int hash(int i) {
+            return i;
+        }
+
+        private static final DefaultIntHashStrategy instance = new DefaultIntHashStrategy();
+        public static DefaultIntHashStrategy getInstance() {
+            return instance;
+        }
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
index 84ed7d2..44ea98d 100644
--- a/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
@@ -102,4 +102,9 @@ public class TacoSpigotConfig {
         config.addDefault(path, def);
         return config.getString(path, config.getString(path));
     }
+
+    public static boolean dataWatcherWeaklyConsistent;
+    private static void dataWatcherWeaklyConsistent() {
+        dataWatcherWeaklyConsistent = getBoolean("data-watcher.weakly-consistent", true);
+    }
 }
-- 
2.4.6.windows.1

