From 462668380159a33ce4ad787d49d3c4c6a8b3b9c0 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Fri, 24 Jul 2015 16:20:18 -0700
Subject: [PATCH] Fix hopper lag by making entities look for hoppers.

Every tick hoppers try and find an block-inventory to extract from.
If no tile entity is above the hopper (which there often isn't) it will do a bounding box search for minecart chests and minecart hoppers.
If it can't find an inventory, it will then look for a dropped item, which is another bounding box search.
This patch eliminates that expensive check by having dropped items and minecart hoppers/chests look for hoppers instead.
Hoppers are tile entities meaning you can do a simple tile entity lookup to find the nearest hopper in range.
Pushing out of hoppers causes a bouding box lookup, which this patch replaces with a tile entity lookup.
This patch may causes a slight decrease in the performance of dropped items, which is why it can be disabled in the configuration.

diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 1f8b1c7..63cd4bd 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -4,6 +4,7 @@ import java.util.Iterator;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.event.player.PlayerPickupItemEvent; // CraftBukkit
+import net.techcable.tacospigot.HopperHelper; // TacoSpigot
 
 public class EntityItem extends Entity {
 
@@ -59,6 +60,7 @@ public class EntityItem extends Entity {
             this.die();
         } else {
             super.t_();
+            if (HopperHelper.acceptItemEntity(this)) return; // TacoSpigot
             // CraftBukkit start - Use wall time for pickup and despawn timers
             int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
             if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
@@ -124,6 +126,7 @@ public class EntityItem extends Entity {
     // Spigot start - copied from above
     @Override
     public void inactiveTick() {
+        if (HopperHelper.acceptItemEntity(this)) return; // TacoSpigot
         // CraftBukkit start - Use wall time for pickup and despawn timers
         int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
         if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
diff --git a/src/main/java/net/minecraft/server/EntityMinecartContainer.java b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
index c6487f2..8ca2d29 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartContainer.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
@@ -7,6 +7,7 @@ import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.inventory.InventoryHolder;
 // CraftBukkit end
+import net.techcable.tacospigot.HopperHelper; // TacoSpigot
 
 public abstract class EntityMinecartContainer extends EntityMinecartAbstract implements ITileInventory {
 
@@ -60,6 +61,20 @@ public abstract class EntityMinecartContainer extends EntityMinecartAbstract imp
 
     }
 
+    // TacoSpigot start
+    @Override
+    public void t_() {
+        super.t_();
+        HopperHelper.acceptItem(this, this);
+    }
+
+    @Override
+    public void inactiveTick() {
+        super.inactiveTick();
+        HopperHelper.acceptItem(this, this);
+    }
+    // TacoSpigot end
+
     public ItemStack getItem(int i) {
         return this.items[i];
     }
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 760a076..25410f8 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -11,6 +11,7 @@ import org.bukkit.event.inventory.InventoryMoveItemEvent;
 import org.bukkit.event.inventory.InventoryPickupItemEvent;
 import org.bukkit.inventory.Inventory;
 // CraftBukkit end
+import net.techcable.tacospigot.HopperHelper; // TacoSpigot
 
 public class TileEntityHopper extends TileEntityContainer implements IHopper, IUpdatePlayerListBox {
 
@@ -89,9 +90,11 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
 
     }
 
+    // TacoSpigot start
     public void update() {
-        super.update();
+        needsUpdate = true;
     }
+    // TacoSpigot end
 
     public int getSize() {
         return this.items.length;
@@ -169,6 +172,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return true;
     }
 
+    private boolean needsUpdate;
     public void c() {
         if (this.world != null && !this.world.isClientSide) {
             --this.g;
@@ -178,6 +182,12 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
             }
 
         }
+        // TacoSpigot start - delay updates till the end of the tick
+        if (needsUpdate) {
+            super.update();
+            needsUpdate = false;
+        }
+        // TacoSpigot end
     }
 
     public boolean m() {
@@ -200,7 +210,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
                 }
             }
             // PaperSpigot start
-            if (world.paperSpigotConfig.useHopperCheck && !this.n()) {
+            if (world.paperSpigotConfig.useHopperCheck && !world.tacoSpigotConfig.isHopperPushBased && !this.n()) { // TacoSpigot - dont use hopper check in push mode
                 this.d(world.spigotConfig.hopperCheck);
             }
             // PaperSpigot end
@@ -225,7 +235,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return true;
     }
 
-    private boolean q() {
+    public boolean q() { // TacoSpigot - expose
         ItemStack[] aitemstack = this.items;
         int i = aitemstack.length;
 
@@ -241,7 +251,13 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
     }
 
     private boolean r() {
-        IInventory iinventory = this.H();
+        // TacoSpigot start - Don't use inefficient H() which does another bounding box search
+        TileEntity tile = getWorld().getTileEntity(getPosition().shift(BlockHopper.b(this.u())));
+        IInventory iinventory;
+        if (tile instanceof TileEntityChest) iinventory = HopperHelper.fastDoubleChestFind((TileEntityChest)tile);
+        else if (tile instanceof IInventory) iinventory = (IInventory) tile;
+        else iinventory = null;
+        // TacoSpigot end
 
         if (iinventory == null) {
             return false;
@@ -346,9 +362,24 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return true;
     }
 
+    // TacoSpigot start - Split methods, one that pushes and one that pulls
+    @Deprecated
     public static boolean a(IHopper ihopper) {
-        IInventory iinventory = b(ihopper);
+        IInventory iinventory;
+        if (ihopper.getWorld().tacoSpigotConfig.isHopperPushBased && ihopper instanceof TileEntityHopper) {
+            TileEntityHopper tileHopper = (TileEntityHopper) ihopper;
+            TileEntity above = ihopper.getWorld().getTileEntity(tileHopper.getPosition().up()); // Only pull from a above, because everything else comes to us
+            if (above instanceof TileEntityChest) iinventory = HopperHelper.fastDoubleChestFind((TileEntityChest)above);
+            else if (above instanceof IInventory) iinventory = (IInventory) above;
+            else iinventory = null;
+        } else {
+            iinventory = b(ihopper); // Use old behavior for BB entity searching
+        }
+        return acceptItem(ihopper, iinventory);
+    }
 
+    public static boolean acceptItem(IHopper ihopper, IInventory iinventory) {
+        // TacoSpigot end
         if (iinventory != null) {
             EnumDirection enumdirection = EnumDirection.DOWN;
 
@@ -374,7 +405,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
                     }
                 }
             }
-        } else {
+        } else if (!ihopper.getWorld().tacoSpigotConfig.isHopperPushBased || !(ihopper instanceof TileEntityHopper)) { // TacoSpigot - only search for entities in 'pull mode'
             Iterator iterator = a(ihopper.getWorld(), ihopper.A(), ihopper.B() + 1.0D, ihopper.C()).iterator();
 
             while (iterator.hasNext()) {
diff --git a/src/main/java/net/techcable/tacospigot/HopperHelper.java b/src/main/java/net/techcable/tacospigot/HopperHelper.java
new file mode 100644
index 0000000..fc84b5b
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/HopperHelper.java
@@ -0,0 +1,80 @@
+package net.techcable.tacospigot;
+
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.BlockHopper;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityItem;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.InventoryLargeChest;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.TileEntityChest;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.World;
+import net.techcable.tacospigot.utils.BlockHelper;
+
+import org.bukkit.Material;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+public class HopperHelper {
+    public static boolean acceptItem(Entity entity, IInventory inventory) {
+        if (!entity.getWorld().tacoSpigotConfig.isHopperPushBased) return false;
+        TileEntityHopper hopper;
+        hopper = getHopper(entity.getWorld(), entity.locX, entity.locY, entity.locZ);
+        if (hopper == null) return false;
+        if (!hopper.n() && !hopper.q() && BlockHopper.f(hopper.u())) return false;
+        return TileEntityHopper.acceptItem(hopper, inventory);
+    }
+
+    public static boolean acceptItemEntity(EntityItem entity) {
+        if (!entity.getWorld().tacoSpigotConfig.isHopperPushBased) return false;
+        if (!entity.isAlive()) return false;
+        TileEntityHopper hopper = getHopper(entity.getWorld(), entity.locX, entity.locY, entity.locZ);
+        if (hopper == null) return false;
+        return TileEntityHopper.a(hopper, entity);
+    }
+
+    // Finding the acceptors
+
+    private static TileEntityHopper getHopper(World world, double rawX, double rawY, double rawZ) {
+        AtomicReference<TileEntityHopper> hopper = new AtomicReference<>();
+        BlockHelper.forEachAdjacentBlock(new BlockPosition(rawX, rawY, rawZ), 1, pos -> {
+            TileEntity tile = world.getTileEntity(pos);
+            if (tile != null && tile instanceof TileEntityHopper) hopper.set((TileEntityHopper) tile);
+        });
+        return hopper.get();
+    }
+
+    // Performance Boost for chest lookup
+    public static final String DOUBLE_CHEST_ID = "container.chestDouble";
+
+    public static IInventory fastDoubleChestFind(TileEntityChest original) {
+        BlockPosition pos = original.getPosition();
+        World world = original.getWorld();
+        // West and North have original on the right
+        // East and South have original on the left
+        TileEntity west = world.getTileEntity(new BlockPosition(pos.getX() - 1, pos.getY(), pos.getZ()));
+        if (west != null && west instanceof TileEntityChest)
+            return new InventoryLargeChest(DOUBLE_CHEST_ID, (TileEntityChest) west, original);
+        TileEntity east = world.getTileEntity(new BlockPosition(pos.getX() + 1, pos.getY(), pos.getZ()));
+        if (east != null && east instanceof TileEntityChest)
+            return new InventoryLargeChest(DOUBLE_CHEST_ID, original, (TileEntityChest) east);
+        TileEntity north = world.getTileEntity(new BlockPosition(pos.getX(), pos.getY(), pos.getZ() - 1));
+        if (north != null && north instanceof TileEntityChest)
+            return new InventoryLargeChest(DOUBLE_CHEST_ID, (TileEntityChest) north, original);
+        TileEntity south = world.getTileEntity(new BlockPosition(pos.getX(), pos.getY(), pos.getZ() + 1));
+        if (south != null && south instanceof TileEntityChest)
+            return new InventoryLargeChest(DOUBLE_CHEST_ID, original, (TileEntityChest) south);
+        return original;
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
index 456aee9..4319a61 100644
--- a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
@@ -63,4 +63,10 @@ public class TacoSpigotWorldConfig {
         config.addDefault("world-settings.default." + path, def);
         return config.getString("world-settings." + worldName + "." + path, config.getString("world-settings.default." + path));
     }
+
+    public boolean isHopperPushBased;
+    private void isHopperPushBased() {
+        isHopperPushBased = getBoolean("hopper.push-based", true);
+    }
+
 }
diff --git a/src/main/java/net/techcable/tacospigot/utils/BlockHelper.java b/src/main/java/net/techcable/tacospigot/utils/BlockHelper.java
new file mode 100644
index 0000000..290cc12
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/utils/BlockHelper.java
@@ -0,0 +1,47 @@
+package net.techcable.tacospigot.utils;
+
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+
+public class BlockHelper {
+    private BlockHelper() {}
+
+    public static void forEachAdjacentBlock(BlockPosition position, int radius, Consumer<BlockPosition> action) {
+        // Hax
+        isAllAdjacentBlocksFillPredicate(position, radius, (pos) -> {
+            action.accept(pos);
+            return true;
+        });
+    }
+
+    public static boolean isAllAdjacentBlocksFillPredicate(BlockPosition position, int radius, Predicate<BlockPosition> predicate) {
+        int startX = position.getX() - radius;
+        int endX = position.getX() + radius;
+        int startY = Math.max(0, position.getY() - radius);
+        int endY = Math.min(255, position.getY() + radius);
+        int startZ = position.getZ() - radius;
+        int endZ = position.getZ() + radius;
+        for (int x = startX; x <= endX; x++) {
+            for (int y = startY; y <= endY; y++) {
+                for (int z = startZ; z <= endZ; z++) {
+                    BlockPosition adjacent = new BlockPosition(x, y, z);
+                    if (!predicate.test(adjacent)) return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    private static Block[] blockById = new Block[256];
+    static {
+        for (int i = 0; i < blockById.length; i++) {
+            blockById[i] = Block.getById(i);
+        }
+    }
+    public static Block getBlock(int id) {
+        return id < 256 ? blockById[id] : Block.getById(id);
+    }
+}
-- 
2.6.1.windows.1

