From 77775e7440ab594d2d4f5ee6217fab18c77afbbd Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Sat, 5 Sep 2015 18:38:09 -0700
Subject: [PATCH] Optimize world.getType() and world.getChunkAt()

Speeds up world.isValidPosition() by only checking for a valid y.
Checks for valid x and zs are only performed when chunks are (attempting)
loading.
Some minor optimizations to Chunk.getBlockData() and World.getChunkAt()

Should help with everything from redstone to entities.

diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index e0bc8aa..5284187 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -507,7 +507,7 @@ public class Chunk {
     }
 
     public IBlockData getBlockData(final BlockPosition blockposition) {
-        if (this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+        if (false /* this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES*/) { // TacoSpigot - never 'DEBUG_ALL_BLOCK_STATES'
             IBlockData iblockdata = null;
 
             if (blockposition.getY() == 60) {
@@ -521,7 +521,8 @@ public class Chunk {
             return iblockdata == null ? Blocks.AIR.getBlockData() : iblockdata;
         } else {
             try {
-                if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
+                // TacoSpigot - assume the 'y' is a valid position (usually true due to a World.isValidPosition check)
+                // if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
                     ChunkSection chunksection = this.sections[blockposition.getY() >> 4];
 
                     if (chunksection != null) {
@@ -530,9 +531,11 @@ public class Chunk {
                         int k = blockposition.getZ() & 15;
 
                         return chunksection.getType(i, j, k);
-                    }
-                }
-
+                        // TacoSpigot start
+                    } else return Blocks.AIR.getBlockData();
+                // }
+                // TacoSpigot end
+            } catch (IndexOutOfBoundsException e) { // TacoSpigot - handle cases where blockposition.getY() is not valid
                 return Blocks.AIR.getBlockData();
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 0e6a37f..689be45 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -2,12 +2,15 @@ package net.minecraft.server;
 
 import com.google.common.collect.Lists;
 import java.io.IOException;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
+
+import gnu.trove.iterator.TLongIterator;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -22,11 +25,14 @@ import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.util.LongObjectHashMap;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
+// TacoSpigot start
+import gnu.trove.set.hash.TLongHashSet;
+// TacoSpigot end
 
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger b = LogManager.getLogger();
-    public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    public TLongHashSet unloadQueue = new TLongHashSet(); // CraftBukkit - LongHashSet // TacoSpigot - use trove
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
     private IChunkLoader chunkLoader;
@@ -73,7 +79,7 @@ public class ChunkProviderServer implements IChunkProvider {
         if (this.world.worldProvider.e()) {
             if (!this.world.c(i, j)) {
                 // CraftBukkit start
-                this.unloadQueue.add(i, j);
+                this.unloadQueue.add(LongHash.toLong(i, j)); // TacoSpigot - trove
 
                 Chunk c = chunks.get(LongHash.toLong(i, j));
                 if (c != null) {
@@ -83,7 +89,7 @@ public class ChunkProviderServer implements IChunkProvider {
             }
         } else {
             // CraftBukkit start
-            this.unloadQueue.add(i, j);
+            this.unloadQueue.add(LongHash.toLong(i, j)); // TacoSpigot - trove
 
             Chunk c = chunks.get(LongHash.toLong(i, j));
             if (c != null) {
@@ -114,9 +120,15 @@ public class ChunkProviderServer implements IChunkProvider {
         return getChunkAt(i, j, null);
     }
 
+    // TacoSpigot start - cache the most recently returned chunk
+    private Chunk lastChunk = null;
     public Chunk getChunkAt(int i, int j, Runnable runnable) {
-        unloadQueue.remove(i, j);
+        if (lastChunk != null && lastChunk.locX == i && lastChunk.locZ == j) return lastChunk;
+        // TacoSpigot end
+        unloadQueue.remove(LongHash.toLong(i, j)); // TacoSpigot - trove
         Chunk chunk = chunks.get(LongHash.toLong(i, j));
+        if (chunk == null) { // TacoSpigot - optimize cases where the chunk is in the map
+        if (!World.isValidChunk(i, j)) throw new IllegalArgumentException("Invalid chunk position " + i + " " + j); // TacoSpigot - throw IllegalArgumentException instead of loading a invalid chunk
         ChunkRegionLoader loader = null;
 
         if (this.chunkLoader instanceof ChunkRegionLoader) {
@@ -124,26 +136,28 @@ public class ChunkProviderServer implements IChunkProvider {
 
         }
         // We can only use the queue for already generated chunks
-        if (chunk == null && loader != null && loader.chunkExists(world, i, j)) {
+        if (loader != null && loader.chunkExists(world, i, j)) { // TacoSpigot
             if (runnable != null) {
                 ChunkIOExecutor.queueChunkLoad(world, loader, this, i, j, runnable);
                 return null;
             } else {
                 chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
             }
-        } else if (chunk == null) {
+        } else { // TacoSpigot
             chunk = originalGetChunkAt(i, j);
         }
+        } // TacoSpigot - close 'if (chunk == null)
 
         // If we didn't load the chunk async and have a callback run it now
         if (runnable != null) {
             runnable.run();
         }
 
+        lastChunk = chunk; // TacoSpigot - cache the chunk
         return chunk;
     }
     public Chunk originalGetChunkAt(int i, int j) {
-        this.unloadQueue.remove(i, j);
+        this.unloadQueue.remove(LongHash.toLong(i, j)); // TacoSpigot - trove
         Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
         boolean newChunk = false;
         // CraftBukkit end
@@ -360,8 +374,12 @@ public class ChunkProviderServer implements IChunkProvider {
         if (!this.world.savingDisabled) {
             // CraftBukkit start
             Server server = this.world.getServer();
-            for (int i = 0; i < 100 && !this.unloadQueue.isEmpty(); ++i) {
-                long chunkcoordinates = this.unloadQueue.popFirst();
+            // TacoSpigot start - trove
+            TLongIterator iterator = this.unloadQueue.iterator();
+            for (int i = 0; i < 100 && iterator.hasNext(); i++) {
+                long chunkcoordinates = iterator.next();
+                iterator.remove();
+                // TacoSpigot end
                 Chunk chunk = this.chunks.get(chunkcoordinates);
                 if (chunk == null) continue;
 
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 158646b..171fa28 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -28,6 +28,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
     // CraftBukkit start
     public boolean chunkExists(World world, int i, int j) {
+        if (!World.isValidChunk(i, j)) return false; // TacoSpigot - ensure valid
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
         if (this.c.contains(chunkcoordintpair)) {
@@ -56,6 +57,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
     }
 
     public Object[] loadChunk(World world, int i, int j) throws IOException {
+        if (!World.isValidChunk(i, j)) return null; // TacoSpigot - ensure valid
         // CraftBukkit end
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
         NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.get(chunkcoordintpair);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 681ee18..35b8522 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -281,9 +281,23 @@ public abstract class World implements IBlockAccess {
         return this.getType(blockposition1).getBlock();
     }
 
-    private boolean isValidLocation(BlockPosition blockposition) {
-        return blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 && blockposition.getY() >= 0 && blockposition.getY() < 256;
+    // TacoSpigot - start optimize isValidLocation
+    /* We check for a valid x and z in loadChunk() by calling isValidChunk
+     * This means we never load an invalid chunk, and avoid a check for invalid chunks for getting from the hash map
+     * In addition, since chunk positions are smaller (by 16 times), bitwise comparisons should be faster
+     * Also we make it static to inline it easier
+     * Make sure to update isValidChunk() whenever isValidLocation() changes
+     */
+    public static boolean isValidLocation(BlockPosition blockposition) {
+        return /*blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 &&*/ blockposition.getY() >= 0 && blockposition.getY() < 256;
+    }
+
+    private static final int MIN_CHUNK_XZ =  -30000000 >> 4;
+    private static final int MAX_CHUNK_XZ = 30000000 >> 4; // You have to do a '<' check here instead of a '<=' check (IDK why)
+    public static boolean isValidChunk(int x, int z) {
+        return x >= MIN_CHUNK_XZ && z >= MIN_CHUNK_XZ && x < MAX_CHUNK_XZ && z < MAX_CHUNK_XZ;
     }
+    // TacoSpigot end
 
     public boolean isEmpty(BlockPosition blockposition) {
         return this.getType(blockposition).getBlock().getMaterial() == Material.AIR;
@@ -780,9 +794,15 @@ public abstract class World implements IBlockAccess {
         if (!this.isValidLocation(blockposition)) {
             return Blocks.AIR.getBlockData();
         } else {
+            // TacoSpigot start - handle invalid chunk positions
+            try {
             Chunk chunk = this.getChunkAtWorldCoords(blockposition);
 
             return chunk.getBlockData(blockposition);
+            } catch (IllegalArgumentException e) {
+                return Blocks.AIR.getBlockData();
+            }
+            // TacoSpigot end
         }
     }
 
-- 
2.4.6.windows.1.812.gd1b00d3

