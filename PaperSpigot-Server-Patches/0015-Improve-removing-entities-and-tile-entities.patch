From ea304ed79088ba7b44f50c7ae73c23482967244f Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Fri, 9 Oct 2015 11:53:49 -0700
Subject: [PATCH] Improve removing entities and tile entities

Java's implementation of List.removeAll is extremely slow for random access lists.
This is currently causing lots of TPS loss when lots of chunk unload activity
occurs, as the process iterates the removal list for every entry in the
source list, resulting in O(n^2) performance.

This change will switch the process to instead iterate over the
removal list, and marking a boolean that its removed.

Then, we then iterate the source list and use a compaction technique
that skips any object marked for removal.

Finally, after all live objects are compacted down, we do a range
removal to clear out any removed objects at the end of the current list.

This gives us O(n) performance and a much cheaper overall operation.

Compaction technique was originally used by CyberTiger in a different
implementation.

This also fixes a bug with Tick Position in the Tick limiter, where
previously .removeAll would shift entity index order but the tick
position was never moved to its new location.

diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 68126c4..9f56204 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -32,7 +32,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.plugin.PluginManager;
 // CraftBukkit end
 
-public abstract class Entity implements ICommandListener {
+public abstract class Entity implements ICommandListener, net.techcable.tacospigot.OptimizedRemoveAll.Marker { // TacoSpigot - implement the marker
 
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
@@ -2238,4 +2238,18 @@ public abstract class Entity implements ICommandListener {
 
         EnchantmentManager.b(entityliving, entity);
     }
+
+    // TacoSpigot start
+    private boolean needsRemoval = false;
+
+    @Override
+    public boolean isNeedRemoval() {
+        return needsRemoval;
+    }
+
+    @Override
+    public void markRemoval() {
+        needsRemoval = true;
+    }
+    // TacoSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index 3fc6450..f82f0bb 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -9,7 +9,7 @@ import org.apache.logging.log4j.Logger;
 import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.bukkit.inventory.InventoryHolder; // CraftBukkit
 
-public abstract class TileEntity {
+public abstract class TileEntity implements net.techcable.tacospigot.OptimizedRemoveAll.Marker { // TacoSpigot - implement the removal marker
 
     public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static final Logger a = LogManager.getLogger();
@@ -246,4 +246,18 @@ public abstract class TileEntity {
         return null;
     }
     // CraftBukkit end
+
+    // TacoSpigot start
+    private boolean needsRemoval = false;
+
+    @Override
+    public boolean isNeedRemoval() {
+        return needsRemoval;
+    }
+
+    @Override
+    public void markRemoval() {
+        needsRemoval = true;
+    }
+    // TacoSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index a4dbd42..a42c1cf 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -23,6 +23,9 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 // PaperSpigot end
+// TacoSpigot start
+import net.techcable.tacospigot.OptimizedRemoveAll;
+// TacoSpigot end
 
 // CraftBukkit start
 // CraftBukkit end
@@ -1408,7 +1411,7 @@ public abstract class World implements IBlockAccess {
         }
 
         this.methodProfiler.c("remove");
-        this.entityList.removeAll(this.g);
+        tickPosition = OptimizedRemoveAll.removeAll(this.entityList, this.g, tickPosition); // TacoSpigot - optimize remove all from O(n^2) to O(n)
 
         int j;
         int k;
@@ -1504,7 +1507,7 @@ public abstract class World implements IBlockAccess {
         this.M = true;
         // CraftBukkit start - From below, clean up tile entities before ticking them
         if (!this.c.isEmpty()) {
-            this.tileEntityList.removeAll(this.c);
+            tileTickPosition = OptimizedRemoveAll.removeAll(this.tileEntityList, this.c, tileTickPosition); // TacoSpigot - optimize remove all from O(n^2) to O(n)
             //this.h.removeAll(this.c); // PaperSpigot - Remove unused list
             this.c.clear();
         }
diff --git a/src/main/java/net/techcable/tacospigot/OptimizedRemoveAll.java b/src/main/java/net/techcable/tacospigot/OptimizedRemoveAll.java
new file mode 100644
index 0000000..1ee8656
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/OptimizedRemoveAll.java
@@ -0,0 +1,47 @@
+package net.techcable.tacospigot;
+
+import java.util.List;
+
+/**
+ * An improved algorithm for bulk removal from a random access list
+ * <p/>
+ * WARNING: This system only works on Identity Based lists
+ */
+public class OptimizedRemoveAll {
+    private OptimizedRemoveAll() {
+    }
+
+    public interface Marker {
+        public boolean isNeedRemoval();
+
+        public void markRemoval();
+    }
+
+    /**
+     * An optimized remove all
+     *
+     * @param list the list to remove from
+     * @param toRemove what to remove
+     * @param position the position to remove from
+     * @param <T> the type being removed
+     * @return the new position
+     */
+    public static <T extends Marker> int removeAll(List<T> list, List<T> toRemove, int position) {
+        int removalSize = toRemove.size();
+        for (int i = 0; i < removalSize; i++) {
+            toRemove.get(i).markRemoval();
+        }
+
+        int size = list.size();
+        int insertAt = 0;
+        for (int i = 0; i < size; i++) {
+            T element = list.get(i);
+            if (i == position) position = insertAt;
+            if (element != null && !element.isNeedRemoval()) {
+                list.set(insertAt++, element);
+            }
+        }
+        list.subList(insertAt, size).clear();
+        return position;
+    }
+}
-- 
2.6.1.windows.1

