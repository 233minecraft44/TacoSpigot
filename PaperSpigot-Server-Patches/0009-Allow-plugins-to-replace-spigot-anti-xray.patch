From d4931a0d51794009b9ae3e08a746c1261f43baad Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Fri, 31 Jul 2015 10:33:42 -0700
Subject: [PATCH] Allow plugins to replace spigot anti xray


diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 1a2484d..9a32581 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -250,9 +250,9 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
             if (!arraylist.isEmpty()) {
                 if (arraylist.size() == 1) {
-                    this.playerConnection.sendPacket(new PacketPlayOutMapChunk((Chunk) arraylist.get(0), true, '\uffff'));
+                    this.playerConnection.sendPacket(new PacketPlayOutMapChunk(this, (Chunk) arraylist.get(0), true, '\uffff')); // TacoSpigot - pass in player
                 } else {
-                    this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(arraylist));
+                    this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(this, arraylist)); // TacoSpigot - pass in player
                 }
 
                 Iterator iterator2 = arraylist1.iterator();
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index a0021fb..688d2c9 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -14,14 +14,26 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
     public PacketPlayOutMapChunk() {}
 
+    private World world; // TacoSpigot - store world
     public PacketPlayOutMapChunk(Chunk chunk, boolean flag, int i) {
         this.a = chunk.locX;
         this.b = chunk.locZ;
+        this.world = chunk.world; // TacoSpigot - store world
         this.d = flag;
         this.c = chunk.getChunkMap(flag, i); // PaperSpigot
-        chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(chunk.locX, chunk.locZ, c.b, c.a, chunk.world);
+        // chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(chunk.locX, chunk.locZ, c.b, c.a, chunk.world); // Spigot // TacoSpigot - use in below constructor
     }
 
+    // TacoSpigot start - add entity arg
+    private boolean obfuscated = false;
+    // This must be added as a separate constructor for compatibility reasons
+    public PacketPlayOutMapChunk(EntityPlayer player, Chunk chunk, boolean flag, int i) {
+        this(chunk, flag, i);
+        chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(player, chunk.locX, chunk.locZ, c.b, c.a, chunk.world); // TacoSpigot - add player arg
+        obfuscated = true;
+    }
+    // TacoSpigot server
+
     public void a(PacketDataSerializer packetdataserializer) throws IOException {
         this.a = packetdataserializer.readInt();
         this.b = packetdataserializer.readInt();
@@ -32,6 +44,11 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
     }
 
     public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        // TacoSpigot start - obfuscate chunk buffer
+        if (!obfuscated) {
+            world.spigotConfig.antiXrayInstance.obfuscate(null, a, b, c.b, c.a, world); // Player is unknown, as it would have otherwise been obfuscated
+        }
+        // TacoSpigot end
         packetdataserializer.writeInt(this.a);
         packetdataserializer.writeInt(this.b);
         packetdataserializer.writeBoolean(this.d);
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
index 00c0538..8d5cbfd 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
@@ -10,6 +10,7 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
     private PacketPlayOutMapChunk.ChunkMap[] c;
     private boolean d;
     private World world; // Spigot
+    private EntityPlayer player; // TacoSpigot
 
     public PacketPlayOutMapChunkBulk() {}
 
@@ -33,6 +34,13 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
         world = ((Chunk) list.get(0)).getWorld(); // Spigot
     }
 
+    // TacoSpigot start - add player argument
+    public PacketPlayOutMapChunkBulk(EntityPlayer player, List<Chunk> chunks) {
+        this(chunks);
+        this.player = player;
+    }
+    // TacoSpigot end
+
     public void a(PacketDataSerializer packetdataserializer) throws IOException {
         this.d = packetdataserializer.readBoolean();
         int i = packetdataserializer.e();
@@ -70,7 +78,7 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
         }
 
         for (i = 0; i < this.a.length; ++i) {
-            world.spigotConfig.antiXrayInstance.obfuscate(this.a[i], this.b[i], this.c[i].b, this.c[i].a, world); // Spigot
+            world.spigotConfig.antiXrayInstance.obfuscate(player, this.a[i], this.b[i], this.c[i].b, this.c[i].a, world); // Spigot // TacoSpigot - pass in player
             packetdataserializer.writeBytes(this.c[i].a);
         }
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 38586aa..a44151a 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -422,7 +422,7 @@ public class PlayerChunkMap {
                 Chunk chunk = PlayerChunkMap.this.world.getChunkAt(this.location.x, this.location.z);
 
                 if (chunk.isReady()) {
-                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(chunk, true, 0));
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(entityplayer, chunk, true, 0)); // TacoSpigot - add player arg
                 }
 
                 this.players.remove(entityplayer); // CraftBukkit
@@ -506,7 +506,13 @@ public class PlayerChunkMap {
                     if (this.dirtyCount == 64) {
                         i = this.location.x * 16;
                         j = this.location.z * 16;
-                        this.a((Packet) (new PacketPlayOutMapChunk(PlayerChunkMap.this.world.getChunkAt(this.location.x, this.location.z), false, this.f)));
+                        // TacoSpigot start - specify which player the map chunk is being sent to, make sure to track sendAll()!
+                        for (EntityPlayer entityplayer : this.b) {
+                            if (!entityplayer.chunkCoordIntPairQueue.contains(this.location)) {
+                                entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(entityplayer, PlayerChunkMap.this.world.getChunkAt(this.location.x, this.location.z), false, this.f));
+                            }
+                        }
+                        // TacoSpigot end
 
                         for (k = 0; k < 16; ++k) {
                             if ((this.f & 1 << k) != 0) {
diff --git a/src/main/java/net/techcable/tacospigot/xray/AntiXRayWrapper.java b/src/main/java/net/techcable/tacospigot/xray/AntiXRayWrapper.java
new file mode 100644
index 0000000..1c158fa
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/xray/AntiXRayWrapper.java
@@ -0,0 +1,197 @@
+package net.techcable.tacospigot.xray;
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.World;
+import net.techcable.tacospigot.BlockData;
+
+import org.bukkit.Material;
+import org.spigotmc.CustomTimingsHandler;
+
+// PaperSpigot start
+// PaperSpigot end
+
+public class AntiXRayWrapper {
+
+    private static final CustomTimingsHandler update = new CustomTimingsHandler("xray - update");
+    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler("xray - obfuscate");
+    /*========================================================================*/
+    // PaperSpigot start
+    public boolean queueUpdates = true;
+    public final Set<BlockPosition> pendingUpdates = new HashSet<BlockPosition>();
+    // PaperSpigot end
+    private AntiXRayEngine engine;
+
+    public AntiXRayEngine getEngine() {
+        return engine;
+    }
+
+    public void setEngine(AntiXRayEngine engine) {
+        this.engine = engine;
+    }
+
+    public AntiXRayWrapper(AntiXRayEngine engine) {
+        this.engine = engine;
+    }
+
+    /**
+     * PaperSpigot - Flush queued block updates for world.
+     */
+    public void flushUpdates(World world) {
+        if (engine != null && !pendingUpdates.isEmpty()) {
+            queueUpdates = false;
+
+            for (BlockPosition position : pendingUpdates) {
+                updateNearbyBlocks(world, position);
+            }
+
+            pendingUpdates.clear();
+            queueUpdates = true;
+        } else {
+            pendingUpdates.clear();
+        }
+    }
+
+    /**
+     * Starts the timings handler, then updates all blocks within the set radius
+     * of the given coordinate, revealing them if they are hidden ores.
+     */
+    public void updateNearbyBlocks(World world, BlockPosition position) {
+
+        // PaperSpigot start
+        if (queueUpdates) {
+            pendingUpdates.add(position);
+            return;
+        }
+        // PaperSpigot end
+        if (engine != null) {
+            update.startTiming();
+            engine.onBlockChange(world.getWorld(), position.getX(), position.getY(), position.getZ());
+            update.stopTiming();
+        }
+    }
+
+    /**
+     * Starts the timings handler, and then removes all non exposed ores from
+     * the chunk buffer.
+     */
+    public void obfuscateSync(EntityPlayer player, int chunkX, int chunkZ, int bitmask, byte[] buffer, World world) {
+        if (engine != null) {
+            obfuscate.startTiming();
+            obfuscate(player, chunkX, chunkZ, bitmask, buffer, world);
+            obfuscate.stopTiming();
+        }
+    }
+
+    public static final int BLOCKS_PER_SECTION = 16 * 16 * 16;
+    private long lastWarn = 0;
+
+    /**
+     * Removes all non exposed ores from the chunk buffer.
+     */
+    public void obfuscate(EntityPlayer player, int chunkX, int chunkZ, int bitmask, byte[] buffer, World world) {
+        if (engine != null) {
+            if (world.getChunkIfLoaded(chunkX, chunkZ) == null) return;
+            int readSections = 0;
+            for (int section = 0; section < 16; section++) {
+                if ((bitmask & (1 << section)) == 0) continue;
+                int index = BLOCKS_PER_SECTION * 2 * readSections; // We have two bytes per block
+                readSections++;
+                // Iteration order must be y, z, x in order to properly keep the index and the position in sync
+                for (int y = 0; y < 16; y++) { // ys are relative to the section, similarly to how x and z are relative to the chunk
+                    for (int z = 0; z < 16; z++) {
+                        xloop : for (int x = 0; x < 16; x++) {
+                            try {
+                                // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
+                                if (index + 1 >= buffer.length) continue;
+
+                                int combinedId = (buffer[index] & 0xFF) | ((buffer[index + 1] & 0xFF) << 8); // Least Significant byte is first, unlike the rest of java
+                                int metadata = combinedId & 0xF; // Block is is the first 4 bits
+                                int blockId = combinedId >> 4; // Block is anything afterwords
+                                Material type = Material.getMaterial(blockId);
+                                if (type == null) throw new UnsupportedOperationException("Unknown material " + blockId + " from data " + combinedId);
+                                if (!type.isBlock()) throw new UnsupportedOperationException("Not a block " + blockId + " from data " + combinedId);
+                                BlockData data = new BlockData(type, metadata);
+                                // The block isn't loaded, bail out
+
+                                // Calculate the real x, y, and z from the relative positions
+                                int realX = (chunkX << 4) | (x & 0xF);
+                                int realZ = (chunkZ << 4) | (z & 0xF);
+                                int realY = (section << 4) | (y & 0xF);
+
+                                // The block isn't loaded, bail out
+                                // note that the chunk has already been checked, eliminating a lot
+                                if (!isValidLocation(realX, realY, realZ, 1)) continue;
+
+                                try {
+                                    data = engine.obfuscate(player == null ? null : player.getBukkitEntity(), world.getWorld(), realX, realY, realZ, data);
+                                } catch (NullPointerException e) {
+                                    /*
+                                     * They expected a non null player, but there wasn't one
+                                     * Certain plugins (LibsDisguises) initialize the packet through reflection, and TacoSpigot adding an argument creates issues with them
+                                     * We obfuscate the chunk anyway, and warn the user they have an incompatibile plugin
+                                     */
+                                    if (player == null) {
+                                        boolean hasToString;
+                                        try {
+                                            engine.getClass().getDeclaredMethod("toString");
+                                            hasToString = true;
+                                        } catch (NoSuchMethodException e2) {
+                                            hasToString = false;
+                                        }
+                                        if (shouldWarn()) {
+                                            String name = hasToString ? engine.toString() : engine.getClass().getSimpleName();
+                                            warn("XRay Engine %s expected a non-null player, did a plugin initialize the chunk packet?", name);
+                                            warn("Plugins that are known to cause this issue: LibsDisguises");
+                                        }
+                                    }
+                                }
+
+                                if (data != null) { // It changed
+                                    combinedId = (byte) ((data.getBlockId() << 4) | (data.getMetadata() & 0xF));
+                                    buffer[index] = (byte) (combinedId & 0xFF);
+                                    buffer[index + 1] = (byte) ((combinedId >> 8) & 0xFF);
+                                }
+                            } finally {
+                                index += 2;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean shouldWarn() {
+        return System.currentTimeMillis() - lastWarn >= TimeUnit.MINUTES.toMillis(5);
+    }
+
+    private void warn(String msg, Object... args) {
+        msg = String.format(msg, args);
+        MinecraftServer.LOGGER.warn(msg);
+        lastWarn = System.currentTimeMillis();
+    }
+
+    private static boolean isValidLocation(int x, int y, int z, int radius) {
+        return isValidLocation(x, y, z)
+                && (radius == 0 ||
+                (isValidLocation(x + 1, y, z) // east
+                && isValidLocation(x - 1, y, z) // west
+                && isValidLocation(x, y + 1, z) // up
+                && isValidLocation(x, y - 1, z) // down
+                && isValidLocation(x, y, z + 1) // south
+                && isValidLocation(x, y, z - 1))); // north
+    }
+
+
+    private static boolean isValidLocation(int x, int y, int z) {
+        return x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000 && y >= 0 && y < 256;
+    }
+
+}
diff --git a/src/main/java/net/techcable/tacospigot/xray/SpigotAntiXray.java b/src/main/java/net/techcable/tacospigot/xray/SpigotAntiXray.java
new file mode 100644
index 0000000..a69745b
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/xray/SpigotAntiXray.java
@@ -0,0 +1,157 @@
+package net.techcable.tacospigot.xray;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.World;
+import net.techcable.tacospigot.BlockData;
+import net.techcable.tacospigot.error.ChunkNotLoadedException;
+
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.Player;
+import org.spigotmc.SpigotWorldConfig;
+
+import gnu.trove.set.TByteSet;
+import gnu.trove.set.hash.TByteHashSet;
+
+public class SpigotAntiXray implements AntiXRayEngine {
+
+    // Used to keep track of which blocks to obfuscate
+    private final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
+    // Used to select a random replacement ore
+    private final byte[] replacementOres;
+
+    public SpigotAntiXray(SpigotWorldConfig config) {
+        // Set all listed blocks as true to be obfuscated
+        for (int id : (config.engineMode == 1) ? config.hiddenBlocks : config.replaceBlocks) {
+            obfuscateBlocks[id] = true;
+        }
+
+        // For every block
+        TByteSet blocks = new TByteHashSet();
+        for (Integer i : config.hiddenBlocks) {
+            Block block = Block.getById(i);
+            // Check it exists and is not a tile entity
+            if (block != null && !block.isTileEntity()) {
+                // Add it to the set of replacement blocks
+                blocks.add((byte) (int) i);
+            }
+        }
+        // Bake it to a flat array of replacements
+        replacementOres = blocks.toArray();
+    }
+
+    @Override
+    public void onBlockChange(org.bukkit.World world, int x, int y, int z) {
+        updateNearbyBlocks(((CraftWorld) world).getHandle(), new BlockPosition(x, y, z), 2, false); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
+    }
+
+
+    @Override
+    public BlockData obfuscateSync(Player player, org.bukkit.World world, int x, int y, int z, BlockData data) {
+        return obfuscate(player, world, x, y, z, data);
+    }
+
+    @Override
+    public BlockData obfuscate(Player player, org.bukkit.World world, int x, int y, int z, BlockData data) {
+        int blockId = obfuscate(player, ((CraftWorld)world).getHandle(), x, y, z, data.getBlockId());
+        if (blockId < 0) return null;
+        return data.withBlockId(blockId);
+    }
+
+    private AtomicInteger randomOre = new AtomicInteger(0); // Could be used from multiple threads
+
+    public int obfuscate(Player player, World world, int x, int y, int z, int blockId) {
+        byte replaceWithTypeId;
+        switch (world.getWorld().getEnvironment()) {
+            case NETHER:
+                replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.NETHERRACK);
+                break;
+            case THE_END:
+                replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.END_STONE);
+                break;
+            default:
+                replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.STONE);
+                break;
+        }
+
+        int initialRadius = 1;
+
+        // Check if the block should be obfuscated
+        if (obfuscateBlocks[blockId]) {
+
+            try {
+                // On the otherhand, if radius is 0, or the nearby blocks are all non air, we can obfuscate
+                if (!hasTransparentBlockAdjacent(world, new BlockPosition(x, y, z), initialRadius)) {
+                    int newId = blockId;
+                    switch (world.spigotConfig.engineMode) {
+                        case 1:
+                            // Replace with replacement material
+                            newId = replaceWithTypeId & 0xFF;
+                            break;
+                        case 2:
+                            // Replace with random ore.
+                            randomOre.compareAndSet(replacementOres.length, 0);
+                            newId = replacementOres[randomOre.getAndIncrement()] & 0xFF;
+                            break;
+                    }
+                    return newId;
+                }
+            } catch (ChunkNotLoadedException e) {
+                return -1;
+            }
+        }
+        return -1; // No change
+    }
+
+    private void updateNearbyBlocks(World world, BlockPosition position, int radius, boolean updateSelf) {
+        // If the block in question is loaded
+        if (world.isLoaded(position)) {
+            // Get block id
+            Block block = world.getType(position).getBlock();
+
+            // See if it needs update
+            if (updateSelf && obfuscateBlocks[Block.getId(block)]) {
+                // Send the update
+                world.notify(position);
+            }
+
+            // Check other blocks for updates
+            if (radius > 0) {
+                updateNearbyBlocks(world, position.east(), radius - 1, true);
+                updateNearbyBlocks(world, position.west(), radius - 1, true);
+                updateNearbyBlocks(world, position.up(), radius - 1, true);
+                updateNearbyBlocks(world, position.down(), radius - 1, true);
+                updateNearbyBlocks(world, position.south(), radius - 1, true);
+                updateNearbyBlocks(world, position.north(), radius - 1, true);
+            }
+        }
+    }
+
+    private static boolean hasTransparentBlockAdjacent(World world, BlockPosition position, int radius) throws ChunkNotLoadedException {
+        Chunk chunk = world.getChunkIfLoaded(position.getX() >> 4, position.getZ() >> 4);
+        if (chunk == null) throw new ChunkNotLoadedException();
+        Block block = chunk.getLastKnownType(position.getX(), position.getY(), position.getZ()) ;
+        return !isSolidBlock(block) /* isSolidBlock */
+                || (radius > 0
+                && (hasTransparentBlockAdjacent(world, position.east(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.west(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.up(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.down(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.south(), radius - 1)
+                || hasTransparentBlockAdjacent(world, position.north(), radius - 1)));
+    }
+
+    private static boolean isSolidBlock(Block block) {
+        // Mob spawners are treated as solid blocks as far as the
+        // game is concerned for lighting and other tasks but for
+        // rendering they can be seen through therefor we special
+        // case them so that the antixray doesn't show the fake
+        // blocks around them.
+        return block.isOccluding() && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index dd82018..1c22456 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -14,6 +14,7 @@ import java.util.UUID;
 
 import net.minecraft.server.*;
 import net.techcable.tacospigot.error.ChunkNotLoadedException; // TacoSpigot
+import net.techcable.tacospigot.xray.AntiXRayEngine; // TacoSpigot
 
 import org.apache.commons.lang.Validate;
 import org.bukkit.BlockChangeDelegate;
@@ -1530,4 +1531,22 @@ public class CraftWorld implements World {
     }
 
     // TacoSpigot end
+    // TacoSpigot start
+
+    @Override
+    public void setAntiXRayEngine(AntiXRayEngine engine) {
+        getHandle().spigotConfig.antiXrayInstance.setEngine(engine);
+    }
+
+    @Override
+    public AntiXRayEngine getAntiXRayEngine() {
+        return getHandle().spigotConfig.antiXrayInstance.getEngine();
+    }
+
+    @Override
+    public AntiXRayEngine getDefaultAntiXRayEngine() {
+        return getHandle().spigotConfig.defaultAntiXray;
+    }
+
+    // TacoSpigot end
 }
diff --git a/src/main/java/org/spigotmc/AntiXray.java b/src/main/java/org/spigotmc/AntiXray.java
deleted file mode 100644
index 5466a61..0000000
--- a/src/main/java/org/spigotmc/AntiXray.java
+++ /dev/null
@@ -1,269 +0,0 @@
-package org.spigotmc;
-
-import gnu.trove.set.TByteSet;
-import gnu.trove.set.hash.TByteHashSet;
-import net.minecraft.server.Block;
-import net.minecraft.server.BlockPosition;
-import net.minecraft.server.Blocks;
-import net.minecraft.server.World;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-
-// PaperSpigot start
-import java.util.HashSet;
-import java.util.Set;
-// PaperSpigot end
-
-public class AntiXray
-{
-
-    private static final CustomTimingsHandler update = new CustomTimingsHandler( "xray - update" );
-    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler( "xray - obfuscate" );
-    /*========================================================================*/
-    // Used to keep track of which blocks to obfuscate
-    private final boolean[] obfuscateBlocks = new boolean[ Short.MAX_VALUE ];
-    // Used to select a random replacement ore
-    private final byte[] replacementOres;
-    // PaperSpigot start
-    public boolean queueUpdates = true;
-    public final Set<BlockPosition> pendingUpdates = new HashSet<BlockPosition>();
-    // PaperSpigot end
-
-    public AntiXray(SpigotWorldConfig config)
-    {
-        // Set all listed blocks as true to be obfuscated
-        for ( int id : ( config.engineMode == 1 ) ? config.hiddenBlocks : config.replaceBlocks )
-        {
-            obfuscateBlocks[id] = true;
-        }
-
-        // For every block
-        TByteSet blocks = new TByteHashSet();
-        for ( Integer i : config.hiddenBlocks )
-        {
-            Block block = Block.getById( i );
-            // Check it exists and is not a tile entity
-            if ( block != null && !block.isTileEntity() )
-            {
-                // Add it to the set of replacement blocks
-                blocks.add( (byte) (int) i );
-            }
-        }
-        // Bake it to a flat array of replacements
-        replacementOres = blocks.toArray();
-    }
-
-    /**
-     * PaperSpigot - Flush queued block updates for world.
-     */
-    public void flushUpdates(World world)
-    {
-        if ( world.spigotConfig.antiXray && !pendingUpdates.isEmpty() )
-        {
-            queueUpdates = false;
-
-            for ( BlockPosition position : pendingUpdates )
-            {
-                updateNearbyBlocks( world, position );
-            }
-
-            pendingUpdates.clear();
-            queueUpdates = true;
-        }
-    }
-
-    /**
-     * Starts the timings handler, then updates all blocks within the set radius
-     * of the given coordinate, revealing them if they are hidden ores.
-     */
-    public void updateNearbyBlocks(World world, BlockPosition position)
-    {
-        if ( world.spigotConfig.antiXray )
-        {
-            // PaperSpigot start
-            if ( queueUpdates )
-            {
-                pendingUpdates.add( position );
-                return;
-            }
-            // PaperSpigot end
-            update.startTiming();
-            updateNearbyBlocks( world, position, 2, false ); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
-            update.stopTiming();
-        }
-    }
-
-    /**
-     * Starts the timings handler, and then removes all non exposed ores from
-     * the chunk buffer.
-     */
-    public void obfuscateSync(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
-    {
-        if ( world.spigotConfig.antiXray )
-        {
-            obfuscate.startTiming();
-            obfuscate( chunkX, chunkY, bitmask, buffer, world );
-            obfuscate.stopTiming();
-        }
-    }
-
-    /**
-     * Removes all non exposed ores from the chunk buffer.
-     */
-    public void obfuscate(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
-    {
-        // If the world is marked as obfuscated
-        if ( world.spigotConfig.antiXray )
-        {
-            // Initial radius to search around for air
-            int initialRadius = 1;
-            // Which block in the buffer we are looking at, anywhere from 0 to 16^4
-            int index = 0;
-            // The iterator marking which random ore we should use next
-            int randomOre = 0;
-
-            // Chunk corner X and Z blocks
-            int startX = chunkX << 4;
-            int startZ = chunkY << 4;
-
-            byte replaceWithTypeId;
-            switch ( world.getWorld().getEnvironment() )
-            {
-                case NETHER:
-                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.NETHERRACK);
-                    break;
-                case THE_END:
-                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.END_STONE);
-                    break;
-                default:
-                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.STONE);
-                    break;
-            }
-
-            // Chunks can have up to 16 sections
-            for ( int i = 0; i < 16; i++ )
-            {
-                // If the bitmask indicates this chunk is sent...
-                if ( ( bitmask & 1 << i ) != 0 )
-                {
-                    // Work through all blocks in the chunk, y,z,x
-                    for ( int y = 0; y < 16; y++ )
-                    {
-                        for ( int z = 0; z < 16; z++ )
-                        {
-                            for ( int x = 0; x < 16; x++ )
-                            {
-                                // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
-                                if ( index >= buffer.length )
-                                {
-                                    index++;
-                                    continue;
-                                }
-                                // Grab the block ID in the buffer.
-                                // TODO: extended IDs are not yet supported
-                                int blockId = (buffer[index << 1] & 0xFF) 
-                                        | ((buffer[(index << 1) + 1] & 0xFF) << 8);
-                                blockId >>>= 4;
-                                // Check if the block should be obfuscated
-                                if ( obfuscateBlocks[blockId] )
-                                {
-                                    // The world isn't loaded, bail out
-                                    if ( !isLoaded( world, new BlockPosition( startX + x, ( i << 4 ) + y, startZ + z ), initialRadius ) )
-                                    {
-                                        index++;
-                                        continue;
-                                    }
-                                    // On the otherhand, if radius is 0, or the nearby blocks are all non air, we can obfuscate
-                                    if ( !hasTransparentBlockAdjacent( world, new BlockPosition( startX + x, ( i << 4 ) + y, startZ + z ), initialRadius ) )
-                                    {
-                                        int newId = blockId;
-                                        switch ( world.spigotConfig.engineMode )
-                                        {
-                                            case 1:
-                                                // Replace with replacement material
-                                                newId = replaceWithTypeId & 0xFF;
-                                                break;
-                                            case 2:
-                                                // Replace with random ore.
-                                                if ( randomOre >= replacementOres.length )
-                                                {
-                                                    randomOre = 0;
-                                                }
-                                                newId = replacementOres[randomOre++] & 0xFF;
-                                                break;
-                                        }
-                                        newId <<= 4;
-                                        buffer[index << 1] = (byte) (newId & 0xFF);
-                                        buffer[(index << 1) + 1] = (byte) ((newId >> 8) & 0xFF);
-                                    }
-                                }
-
-                                index++;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private void updateNearbyBlocks(World world, BlockPosition position, int radius, boolean updateSelf)
-    {
-        // If the block in question is loaded
-        if ( world.isLoaded( position ) )
-        {
-            // Get block id
-            Block block = world.getType(position).getBlock();
-
-            // See if it needs update
-            if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
-            {
-                // Send the update
-                world.notify( position );
-            }
-
-            // Check other blocks for updates
-            if ( radius > 0 )
-            {
-                updateNearbyBlocks( world, position.east(), radius - 1, true );
-                updateNearbyBlocks( world, position.west(), radius - 1, true );
-                updateNearbyBlocks( world, position.up(), radius - 1, true );
-                updateNearbyBlocks( world, position.down(), radius - 1, true );
-                updateNearbyBlocks( world, position.south(), radius - 1, true );
-                updateNearbyBlocks( world, position.north(), radius - 1, true );
-            }
-        }
-    }
-
-    private static boolean isLoaded(World world, BlockPosition position, int radius)
-    {
-        return world.isLoaded( position )
-                && ( radius == 0 ||
-                ( isLoaded( world, position.east(), radius - 1 )
-                && isLoaded( world, position.west(), radius - 1 )
-                && isLoaded( world, position.up(), radius - 1 )
-                && isLoaded( world, position.down(), radius - 1 )
-                && isLoaded( world, position.south(), radius - 1 )
-                && isLoaded( world, position.north(), radius - 1 ) ) );
-    }
-
-    private static boolean hasTransparentBlockAdjacent(World world, BlockPosition position, int radius)
-    {
-        return !isSolidBlock(world.getType(position, false).getBlock()) /* isSolidBlock */
-                || ( radius > 0
-                && ( hasTransparentBlockAdjacent( world, position.east(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.west(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.up(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.down(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.south(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.north(), radius - 1 ) ) );
-    }
-
-    private static boolean isSolidBlock(Block block) {
-        // Mob spawners are treated as solid blocks as far as the
-        // game is concerned for lighting and other tasks but for
-        // rendering they can be seen through therefor we special
-        // case them so that the antixray doesn't show the fake
-        // blocks around them.
-        return block.isOccluding() && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
-    }
-}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index ab2f8bf..39fc5fb 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -2,6 +2,14 @@ package org.spigotmc;
 
 import java.util.Arrays;
 import java.util.List;
+
+// TacoSpigot start
+import net.techcable.tacospigot.xray.AntiXRayWrapper;
+import net.techcable.tacospigot.xray.AntiXRayEngine;
+import net.techcable.tacospigot.xray.SpigotAntiXray;
+// TacoSpigot end
+
+
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
@@ -220,7 +228,8 @@ public class SpigotWorldConfig
     public int engineMode;
     public List<Integer> hiddenBlocks;
     public List<Integer> replaceBlocks;
-    public AntiXray antiXrayInstance;
+    public AntiXRayWrapper antiXrayInstance;
+    public AntiXRayEngine defaultAntiXray; // TacoSpigot
     private void antiXray()
     {
         antiXray = getBoolean( "anti-xray.enabled", true );
@@ -245,7 +254,10 @@ public class SpigotWorldConfig
         } ) );
         log( "\tReplace Blocks: " + replaceBlocks );
 
-        antiXrayInstance = new AntiXray( this );
+        // TacoSpigot start
+        defaultAntiXray = antiXray ? new SpigotAntiXray(this) : null;
+        antiXrayInstance = new AntiXRayWrapper(defaultAntiXray);
+        // TacoSpigot end
     }
 
     public boolean zombieAggressiveTowardsVillager;
-- 
2.4.6.windows.1.812.gd1b00d3

