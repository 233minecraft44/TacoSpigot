From 8e71b348c321e44f486a6286c9f33d62dd425bc0 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Fri, 31 Jul 2015 10:33:42 -0700
Subject: [PATCH] Allow plugins to replace spigot anti xray


diff --git a/src/main/java/net/techcable/tacospigot/xray/AntiXray.java b/src/main/java/net/techcable/tacospigot/xray/AntiXray.java
new file mode 100644
index 0000000..0274b9d
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/xray/AntiXray.java
@@ -0,0 +1,87 @@
+package net.techcable.tacospigot.xray;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.World;
+import net.techcable.tacospigot.BlockPos;
+
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.spigotmc.CustomTimingsHandler;
+
+public class AntiXray {
+
+    private static final CustomTimingsHandler update = new CustomTimingsHandler("xray - update");
+    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler("xray - obfuscate");
+    /*========================================================================*/
+    public boolean queueUpdates = true;
+    public final Set<BlockPosition> pendingUpdates = new HashSet<BlockPosition>();
+    private AntiXRayEngine engine;
+
+    public AntiXray(AntiXRayEngine engine) {
+        this.engine = engine;
+    }
+
+    public AntiXRayEngine getEngine() {
+        return engine;
+    }
+
+    public void setEngine(AntiXRayEngine engine) {
+        this.engine = engine;
+    }
+
+    public void flushUpdates(World world) {
+        if (engine == null) return;
+        if (!pendingUpdates.isEmpty()) {
+            queueUpdates = false;
+
+            for (BlockPosition position : pendingUpdates) {
+                updateNearbyBlocks(world, position);
+            }
+
+            pendingUpdates.clear();
+            queueUpdates = true;
+        }
+    }
+
+    /**
+     * Starts the timings handler, then updates all blocks within the set radius
+     * of the given coordinate, revealing them if they are hidden ores.
+     */
+    public void updateNearbyBlocks(World world, BlockPosition position) {
+            if (engine == null) return;
+            // PaperSpigot start
+            if (queueUpdates) {
+                pendingUpdates.add(position);
+                return;
+            }
+            // PaperSpigot end
+            update.startTiming();
+            engine.onBlockChange(world.getWorld(), new BlockPos(position.getX(), position.getY(), position.getZ()));
+            update.stopTiming();
+    }
+
+    /**
+     * Starts the timings handler, and then removes all non exposed ores from
+     * the chunk buffer.
+     */
+    public void obfuscateSync(int chunkX, int chunkY, int bitmask, byte[] buffer, World world) {
+        if (world.spigotConfig.antiXray) {
+            obfuscate.startTiming();
+            obfuscate(chunkX, chunkY, bitmask, buffer, world);
+            obfuscate.stopTiming();
+        }
+    }
+
+    /**
+     * Removes all non exposed ores from the chunk buffer.
+     */
+    public void obfuscate(int chunkX, int chunkZ, int bitmask, byte[] buffer, World world) {
+        if (engine == null) return;
+        BufferChunkIterator chunkIterator = new BufferChunkIterator(buffer, bitmask);
+        engine.obfuscate(world.getWorld(), chunkX, chunkZ, chunkIterator);
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/xray/BufferChunkIterator.java b/src/main/java/net/techcable/tacospigot/xray/BufferChunkIterator.java
new file mode 100644
index 0000000..6b33f68
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/xray/BufferChunkIterator.java
@@ -0,0 +1,150 @@
+package net.techcable.tacospigot.xray;
+
+import java.util.NoSuchElementException;
+
+import net.techcable.tacospigot.BlockPos;
+
+import org.bukkit.Material;
+
+public class BufferChunkIterator implements ChunkDataIterator {
+
+    private final byte[] buffer;
+    private final int bitmask;
+
+    public BufferChunkIterator(byte[] buffer, int bitmask) {
+        this.buffer = buffer;
+        this.bitmask = bitmask;
+    }
+
+    public byte[] getBuffer() {
+        return buffer;
+    }
+
+    @Override
+    public boolean isSent(int section) {
+        return (bitmask & 1 << section) != 0;
+    }
+
+    //
+    // Methods that use my wrapper things
+    //
+
+    private int x, y, z, section;
+    private int index = -1;
+
+    @Override
+    public boolean hasNext() {
+        if (index == -1) {
+            for (int section = this.section; section < 16; section++) {
+                if (isSent(section)) return true;
+            }
+            return false;
+        }
+        if ((y + 1) < 16 && (z + 1) < 16 && (x + 1) < 16) return true; // More data in section
+        for (int section = this.section; section < 16; section++) {
+            if (isSent(section)) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public BlockPos advance() {
+        if (index == -1) {
+            for (int section = this.section; section < 16; section++) {
+                if (!isSent(section)) continue;
+                return advance(0, 0, 0, section);
+            }
+            throw new NoSuchElementException("No elements in chunk buffer");
+        }
+        // Iteration order: y, z, x;
+        if ((y + 1) < 16) {
+            return advance(x, y + 1, z, section);
+        } else if ((z + 1) < 16) {
+            return advance(x, y, z + 1, section);
+        } else if ((x + 1) < 16) {
+            return advance(x + 1, y, z, section);
+        } else {
+            for (int section = this.section; section < 16; section++) {
+                if (!isSent(section)) continue;
+                return advance(0, 0, 0, section);
+            }
+            throw new NoSuchElementException();
+        }
+    }
+
+    public BlockPos advance(int x, int y, int z, int section) {
+        this.x = x;
+        this.y = y & 0xF; // Make absolutely sure we are relative to the section
+        this.z = z;
+        this.section = section;
+        this.index++;
+        // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
+        if (index >= buffer.length) return advance();
+        return getCurrentPosition();
+    }
+
+    public int getRealY() {
+        return (y & 0xF) | ((section << 4) & 0xF0);
+    }
+
+    @Override
+    public BlockPos getCurrentPosition() {
+        return new BlockPos(x, getRealY(), z);
+    }
+
+    @Override
+    public BlockPos getAbsolutePosition(int chunkX, int chunkZ) {
+        return getCurrentPosition().toAbsolute(chunkX, chunkZ);
+    }
+
+    @Override
+    public void setBlockId(int newId) {
+        int combinedId = getCombinedId();
+        combinedId ^= 0xF0; // Unset the old bits
+        combinedId |= (newId << 4);
+        setCombinedId(combinedId);
+    }
+
+    @Override
+    public void setBlockType(Material type) {
+        setBlockId(type.getId());
+    }
+
+    @Override
+    public Material getBlockType() {
+        int blockId = getBlockId();
+        return Material.getMaterial(blockId);
+    }
+
+    @Override
+    public int getBlockId() {
+        return getCombinedId() >>> 4;
+    }
+
+    @Override
+    public boolean isSent() {
+        return isSent(section);
+    }
+
+    @Override
+    public int getBlockMeta() {
+        return getCombinedId() & 0xF;
+    }
+
+    @Override
+    public void setBlockMeta(int meta) {
+        int combinedId = getCombinedId();
+        combinedId ^= 0xF; // Unset the old bits
+        combinedId |= (meta & 0xF);
+        setCombinedId(combinedId);
+    }
+
+    private int getCombinedId() {
+        return (buffer[index << 1] & 0xFF) | ((buffer[(index << 1) + 1] & 0xFF) << 8);
+    }
+
+    private void setCombinedId(int newId) {
+        buffer[index << 1] = (byte) (newId & 0xFF);
+        buffer[(index << 1) + 1] = (byte) ((newId >> 8) & 0xFF);
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/xray/SpigotAntiXray.java b/src/main/java/net/techcable/tacospigot/xray/SpigotAntiXray.java
new file mode 100644
index 0000000..4383b0a
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/xray/SpigotAntiXray.java
@@ -0,0 +1,299 @@
+package net.techcable.tacospigot.xray;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.World;
+import net.techcable.tacospigot.BlockPos;
+
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.spigotmc.SpigotWorldConfig;
+
+import gnu.trove.set.TByteSet;
+import gnu.trove.set.hash.TByteHashSet;
+
+public class SpigotAntiXray implements AntiXRayEngine // TacoSpigot - rename, move, and implement AntiXRayEngine
+{
+
+    /* // TacoSpigot
+    private static final CustomTimingsHandler update = new CustomTimingsHandler( "xray - update" );
+    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler( "xray - obfuscate" );
+    /*========================================================================*/
+    // Used to keep track of which blocks to obfuscate
+    private final boolean[] obfuscateBlocks = new boolean[ Short.MAX_VALUE ];
+    // Used to select a random replacement ore
+    private final byte[] replacementOres;
+    /* // TacoSpigot
+    // PaperSpigot start
+    public boolean queueUpdates = true;
+    public final Set<BlockPosition> pendingUpdates = new HashSet<BlockPosition>();
+    // PaperSpigot end
+    */ // TacoSpigot
+
+    public SpigotAntiXray(SpigotWorldConfig config)
+    {
+        // Set all listed blocks as true to be obfuscated
+        for ( int id : ( config.engineMode == 1 ) ? config.hiddenBlocks : config.replaceBlocks )
+        {
+            obfuscateBlocks[id] = true;
+        }
+
+        // For every block
+        TByteSet blocks = new TByteHashSet();
+        for ( Integer i : config.hiddenBlocks )
+        {
+            Block block = Block.getById( i );
+            // Check it exists and is not a tile entity
+            if ( block != null && !block.isTileEntity() )
+            {
+                // Add it to the set of replacement blocks
+                blocks.add( (byte) (int) i );
+            }
+        }
+        // Bake it to a flat array of replacements
+        replacementOres = blocks.toArray();
+    }
+
+    /* // TacoSpigot - remove paper comment, comment out unneaded code
+    public void flushUpdates(World world)
+    {
+        if ( world.spigotConfig.antiXray && !pendingUpdates.isEmpty() )
+        {
+            queueUpdates = false;
+
+            for ( BlockPosition position : pendingUpdates )
+            {
+                updateNearbyBlocks( world, position );
+            }
+
+            pendingUpdates.clear();
+            queueUpdates = true;
+        }
+    }
+
+    */ // TacoSpigot
+
+    // TacoSpigot start - remove comment, fit interface
+    public void onBlockChange(org.bukkit.World bukkitWorld, BlockPos tacoPos)
+    {
+        // TacoSpigot start
+        BlockPosition position = new BlockPosition(tacoPos.getX(), tacoPos.getY(), tacoPos.getZ());
+        World world = ((CraftWorld)bukkitWorld).getHandle();
+        if ( true )
+        {
+            /*
+            // TacoSpigot end
+            // PaperSpigot start
+            if ( queueUpdates )
+            {
+                pendingUpdates.add( position );
+                return;
+            }
+            // PaperSpigot end
+            update.startTiming();
+            */ // TacoSpigot
+            updateNearbyBlocks( world, position, 2, false ); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
+            // update.stopTiming(); // TacoSpigot
+        }
+    }
+
+
+    /**
+     * Starts the timings handler, and then removes all non exposed ores from
+     * the chunk buffer.
+     */
+    // TacoSpigot start - reorder params, pass in data wrapper instead of raw data, always run, and don't use timings
+    public void obfuscateSync(org.bukkit.World world, int chunkX, int chunkZ, ChunkDataIterator data)
+    {
+        if ( true )
+        {
+            // obfuscate.startTiming();
+            obfuscate( world, chunkX, chunkZ, data );
+            // obfuscate.stopTiming();
+            // TacoSpigot end
+        }
+    }
+
+    /**
+     * Removes all non exposed ores from the chunk buffer.
+     */
+    // TacoSpigot start
+    public void obfuscate(org.bukkit.World bukkitWorld, int chunkX, int chunkZ, ChunkDataIterator iterator)
+    {
+        World world = ((CraftWorld)bukkitWorld).getHandle();
+        // If the world is marked as obfuscated
+        if ( true )
+        {
+            // TacoSpigot end
+            // Initial radius to search around for air
+            int initialRadius = 1;
+            // Which block in the buffer we are looking at, anywhere from 0 to 16^4
+            int index = 0;
+            // The iterator marking which random ore we should use next
+            int randomOre = 0;
+
+            // Chunk corner X and Z blocks
+            int startX = chunkX << 4;
+            int startZ = chunkZ << 4;
+
+            byte replaceWithTypeId;
+            switch ( world.getWorld().getEnvironment() ) // TacoSpigot - already bukkit world
+            {
+                case NETHER:
+                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.NETHERRACK);
+                    break;
+                case THE_END:
+                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.END_STONE);
+                    break;
+                default:
+                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.STONE);
+                    break;
+            }
+
+            // TacoSpigot start
+            while (iterator.hasNext()) {
+            /*
+            // Chunks can have up to 16 sections
+            for ( int i = 0; i < 16; i++ )
+            {
+                // If the bitmask indicates this chunk is sent...
+                if ( ( bitmask & 1 << i ) != 0 )
+                {
+                    // Work through all blocks in the chunk, y,z,x
+                    for ( int y = 0; y < 16; y++ )
+                    {
+                        for ( int z = 0; z < 16; z++ )
+                        {
+                            for ( int x = 0; x < 16; x++ )
+                            {
+                                // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
+                                if ( index >= buffer.length )
+                                {
+                                    index++;
+                                    continue;
+                                }
+                                */
+                                // Grab the block ID in the buffer.
+                                // TODO: extended IDs are not yet supported
+                                int blockId = iterator.getBlockId();
+                                // TacoSpigot end
+                                //
+                                // Check if the block should be obfuscated
+                                if ( obfuscateBlocks[blockId] )
+                                {
+                                    // The world isn't loaded, bail out
+                                    // TacoSpigot start
+                                    BlockPos absoluteTaco = iterator.getAbsolutePosition(chunkX, chunkZ);
+                                    BlockPosition absolute = new BlockPosition(absoluteTaco.getX(), absoluteTaco.getY(), absoluteTaco.getZ());
+                                    if ( !isLoaded( world, absolute, initialRadius ) )
+                                    {
+                                        // index++;
+                                        // TacoSpigot end
+                                        continue;
+                                    }
+                                    // TacoSpigot start
+                                    // On the otherhand, if radius is 0, or the nearby blocks are all non air, we can obfuscate
+                                    if ( !hasTransparentBlockAdjacent( world, absolute, initialRadius ) )
+                                    {
+                                        // TacoSpigot end
+                                        int newId = blockId;
+                                        switch ( world.spigotConfig.engineMode )
+                                        {
+                                            case 1:
+                                                // Replace with replacement material
+                                                newId = replaceWithTypeId & 0xFF;
+                                                break;
+                                            case 2:
+                                                // Replace with random ore.
+                                                if ( randomOre >= replacementOres.length )
+                                                {
+                                                    randomOre = 0;
+                                                }
+                                                newId = replacementOres[randomOre++] & 0xFF;
+                                                break;
+                                        }
+                                        // TacoSpigot start
+                                        iterator.setBlockId(newId);
+                                        /*
+                                        newId <<= 4;
+                                        buffer[index << 1] = (byte) (newId & 0xFF);
+                                        buffer[(index << 1) + 1] = (byte) ((newId >> 8) & 0xFF);
+                                        */
+                                        // TacoSpigot end
+                                    }
+                                }
+
+                                // TacoSpigot start
+                                // index++;
+                            }
+                            /*
+                        }
+                    }
+                }
+            }
+        */
+        }
+    }
+
+    private void updateNearbyBlocks(World world, BlockPosition position, int radius, boolean updateSelf)
+    {
+        // If the block in question is loaded
+        if ( world.isLoaded( position ) )
+        {
+            // Get block id
+            Block block = world.getType(position).getBlock();
+
+            // See if it needs update
+            if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
+            {
+                // Send the update
+                world.notify( position );
+            }
+
+            // Check other blocks for updates
+            if ( radius > 0 )
+            {
+                updateNearbyBlocks( world, position.east(), radius - 1, true );
+                updateNearbyBlocks( world, position.west(), radius - 1, true );
+                updateNearbyBlocks( world, position.up(), radius - 1, true );
+                updateNearbyBlocks( world, position.down(), radius - 1, true );
+                updateNearbyBlocks( world, position.south(), radius - 1, true );
+                updateNearbyBlocks( world, position.north(), radius - 1, true );
+            }
+        }
+    }
+
+    private static boolean isLoaded(World world, BlockPosition position, int radius)
+    {
+        return world.isLoaded( position )
+                && ( radius == 0 ||
+                ( isLoaded( world, position.east(), radius - 1 )
+                && isLoaded( world, position.west(), radius - 1 )
+                && isLoaded( world, position.up(), radius - 1 )
+                && isLoaded( world, position.down(), radius - 1 )
+                && isLoaded( world, position.south(), radius - 1 )
+                && isLoaded( world, position.north(), radius - 1 ) ) );
+    }
+
+    private static boolean hasTransparentBlockAdjacent(World world, BlockPosition position, int radius)
+    {
+        return !isSolidBlock(world.getType(position, false).getBlock()) /* isSolidBlock */
+                || ( radius > 0
+                && ( hasTransparentBlockAdjacent( world, position.east(), radius - 1 )
+                || hasTransparentBlockAdjacent( world, position.west(), radius - 1 )
+                || hasTransparentBlockAdjacent( world, position.up(), radius - 1 )
+                || hasTransparentBlockAdjacent( world, position.down(), radius - 1 )
+                || hasTransparentBlockAdjacent( world, position.south(), radius - 1 )
+                || hasTransparentBlockAdjacent( world, position.north(), radius - 1 ) ) );
+    }
+
+    private static boolean isSolidBlock(Block block) {
+        // Mob spawners are treated as solid blocks as far as the
+        // game is concerned for lighting and other tasks but for
+        // rendering they can be seen through therefor we special
+        // case them so that the antixray doesn't show the fake
+        // blocks around them.
+        return block.isOccluding() && block != Blocks.MOB_SPAWNER;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index dd82018..1c22456 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -14,6 +14,7 @@ import java.util.UUID;
 
 import net.minecraft.server.*;
 import net.techcable.tacospigot.error.ChunkNotLoadedException; // TacoSpigot
+import net.techcable.tacospigot.xray.AntiXRayEngine; // TacoSpigot
 
 import org.apache.commons.lang.Validate;
 import org.bukkit.BlockChangeDelegate;
@@ -1530,4 +1531,22 @@ public class CraftWorld implements World {
     }
 
     // TacoSpigot end
+    // TacoSpigot start
+
+    @Override
+    public void setAntiXRayEngine(AntiXRayEngine engine) {
+        getHandle().spigotConfig.antiXrayInstance.setEngine(engine);
+    }
+
+    @Override
+    public AntiXRayEngine getAntiXRayEngine() {
+        return getHandle().spigotConfig.antiXrayInstance.getEngine();
+    }
+
+    @Override
+    public AntiXRayEngine getDefaultAntiXRayEngine() {
+        return getHandle().spigotConfig.defaultAntiXray;
+    }
+
+    // TacoSpigot end
 }
diff --git a/src/main/java/org/spigotmc/AntiXray.java b/src/main/java/org/spigotmc/AntiXray.java
deleted file mode 100644
index a59583e..0000000
--- a/src/main/java/org/spigotmc/AntiXray.java
+++ /dev/null
@@ -1,269 +0,0 @@
-package org.spigotmc;
-
-import gnu.trove.set.TByteSet;
-import gnu.trove.set.hash.TByteHashSet;
-import net.minecraft.server.Block;
-import net.minecraft.server.BlockPosition;
-import net.minecraft.server.Blocks;
-import net.minecraft.server.World;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-
-// PaperSpigot start
-import java.util.HashSet;
-import java.util.Set;
-// PaperSpigot end
-
-public class AntiXray
-{
-
-    private static final CustomTimingsHandler update = new CustomTimingsHandler( "xray - update" );
-    private static final CustomTimingsHandler obfuscate = new CustomTimingsHandler( "xray - obfuscate" );
-    /*========================================================================*/
-    // Used to keep track of which blocks to obfuscate
-    private final boolean[] obfuscateBlocks = new boolean[ Short.MAX_VALUE ];
-    // Used to select a random replacement ore
-    private final byte[] replacementOres;
-    // PaperSpigot start
-    public boolean queueUpdates = true;
-    public final Set<BlockPosition> pendingUpdates = new HashSet<BlockPosition>();
-    // PaperSpigot end
-
-    public AntiXray(SpigotWorldConfig config)
-    {
-        // Set all listed blocks as true to be obfuscated
-        for ( int id : ( config.engineMode == 1 ) ? config.hiddenBlocks : config.replaceBlocks )
-        {
-            obfuscateBlocks[id] = true;
-        }
-
-        // For every block
-        TByteSet blocks = new TByteHashSet();
-        for ( Integer i : config.hiddenBlocks )
-        {
-            Block block = Block.getById( i );
-            // Check it exists and is not a tile entity
-            if ( block != null && !block.isTileEntity() )
-            {
-                // Add it to the set of replacement blocks
-                blocks.add( (byte) (int) i );
-            }
-        }
-        // Bake it to a flat array of replacements
-        replacementOres = blocks.toArray();
-    }
-
-    /**
-     * PaperSpigot - Flush queued block updates for world.
-     */
-    public void flushUpdates(World world)
-    {
-        if ( world.spigotConfig.antiXray && !pendingUpdates.isEmpty() )
-        {
-            queueUpdates = false;
-
-            for ( BlockPosition position : pendingUpdates )
-            {
-                updateNearbyBlocks( world, position );
-            }
-
-            pendingUpdates.clear();
-            queueUpdates = true;
-        }
-    }
-
-    /**
-     * Starts the timings handler, then updates all blocks within the set radius
-     * of the given coordinate, revealing them if they are hidden ores.
-     */
-    public void updateNearbyBlocks(World world, BlockPosition position)
-    {
-        if ( world.spigotConfig.antiXray )
-        {
-            // PaperSpigot start
-            if ( queueUpdates )
-            {
-                pendingUpdates.add( position );
-                return;
-            }
-            // PaperSpigot end
-            update.startTiming();
-            updateNearbyBlocks( world, position, 2, false ); // 2 is the radius, we shouldn't change it as that would make it exponentially slower
-            update.stopTiming();
-        }
-    }
-
-    /**
-     * Starts the timings handler, and then removes all non exposed ores from
-     * the chunk buffer.
-     */
-    public void obfuscateSync(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
-    {
-        if ( world.spigotConfig.antiXray )
-        {
-            obfuscate.startTiming();
-            obfuscate( chunkX, chunkY, bitmask, buffer, world );
-            obfuscate.stopTiming();
-        }
-    }
-
-    /**
-     * Removes all non exposed ores from the chunk buffer.
-     */
-    public void obfuscate(int chunkX, int chunkY, int bitmask, byte[] buffer, World world)
-    {
-        // If the world is marked as obfuscated
-        if ( world.spigotConfig.antiXray )
-        {
-            // Initial radius to search around for air
-            int initialRadius = 1;
-            // Which block in the buffer we are looking at, anywhere from 0 to 16^4
-            int index = 0;
-            // The iterator marking which random ore we should use next
-            int randomOre = 0;
-
-            // Chunk corner X and Z blocks
-            int startX = chunkX << 4;
-            int startZ = chunkY << 4;
-
-            byte replaceWithTypeId;
-            switch ( world.getWorld().getEnvironment() )
-            {
-                case NETHER:
-                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.NETHERRACK);
-                    break;
-                case THE_END:
-                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.END_STONE);
-                    break;
-                default:
-                    replaceWithTypeId = (byte) CraftMagicNumbers.getId(Blocks.STONE);
-                    break;
-            }
-
-            // Chunks can have up to 16 sections
-            for ( int i = 0; i < 16; i++ )
-            {
-                // If the bitmask indicates this chunk is sent...
-                if ( ( bitmask & 1 << i ) != 0 )
-                {
-                    // Work through all blocks in the chunk, y,z,x
-                    for ( int y = 0; y < 16; y++ )
-                    {
-                        for ( int z = 0; z < 16; z++ )
-                        {
-                            for ( int x = 0; x < 16; x++ )
-                            {
-                                // For some reason we can get too far ahead of ourselves (concurrent modification on bulk chunks?) so if we do, just abort and move on
-                                if ( index >= buffer.length )
-                                {
-                                    index++;
-                                    continue;
-                                }
-                                // Grab the block ID in the buffer.
-                                // TODO: extended IDs are not yet supported
-                                int blockId = (buffer[index << 1] & 0xFF) 
-                                        | ((buffer[(index << 1) + 1] & 0xFF) << 8);
-                                blockId >>>= 4;
-                                // Check if the block should be obfuscated
-                                if ( obfuscateBlocks[blockId] )
-                                {
-                                    // The world isn't loaded, bail out
-                                    if ( !isLoaded( world, new BlockPosition( startX + x, ( i << 4 ) + y, startZ + z ), initialRadius ) )
-                                    {
-                                        index++;
-                                        continue;
-                                    }
-                                    // On the otherhand, if radius is 0, or the nearby blocks are all non air, we can obfuscate
-                                    if ( !hasTransparentBlockAdjacent( world, new BlockPosition( startX + x, ( i << 4 ) + y, startZ + z ), initialRadius ) )
-                                    {
-                                        int newId = blockId;
-                                        switch ( world.spigotConfig.engineMode )
-                                        {
-                                            case 1:
-                                                // Replace with replacement material
-                                                newId = replaceWithTypeId & 0xFF;
-                                                break;
-                                            case 2:
-                                                // Replace with random ore.
-                                                if ( randomOre >= replacementOres.length )
-                                                {
-                                                    randomOre = 0;
-                                                }
-                                                newId = replacementOres[randomOre++] & 0xFF;
-                                                break;
-                                        }
-                                        newId <<= 4;
-                                        buffer[index << 1] = (byte) (newId & 0xFF);
-                                        buffer[(index << 1) + 1] = (byte) ((newId >> 8) & 0xFF);
-                                    }
-                                }
-
-                                index++;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private void updateNearbyBlocks(World world, BlockPosition position, int radius, boolean updateSelf)
-    {
-        // If the block in question is loaded
-        if ( world.isLoaded( position ) )
-        {
-            // Get block id
-            Block block = world.getType(position).getBlock();
-
-            // See if it needs update
-            if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
-            {
-                // Send the update
-                world.notify( position );
-            }
-
-            // Check other blocks for updates
-            if ( radius > 0 )
-            {
-                updateNearbyBlocks( world, position.east(), radius - 1, true );
-                updateNearbyBlocks( world, position.west(), radius - 1, true );
-                updateNearbyBlocks( world, position.up(), radius - 1, true );
-                updateNearbyBlocks( world, position.down(), radius - 1, true );
-                updateNearbyBlocks( world, position.south(), radius - 1, true );
-                updateNearbyBlocks( world, position.north(), radius - 1, true );
-            }
-        }
-    }
-
-    private static boolean isLoaded(World world, BlockPosition position, int radius)
-    {
-        return world.isLoaded( position )
-                && ( radius == 0 ||
-                ( isLoaded( world, position.east(), radius - 1 )
-                && isLoaded( world, position.west(), radius - 1 )
-                && isLoaded( world, position.up(), radius - 1 )
-                && isLoaded( world, position.down(), radius - 1 )
-                && isLoaded( world, position.south(), radius - 1 )
-                && isLoaded( world, position.north(), radius - 1 ) ) );
-    }
-
-    private static boolean hasTransparentBlockAdjacent(World world, BlockPosition position, int radius)
-    {
-        return !isSolidBlock(world.getType(position, false).getBlock()) /* isSolidBlock */
-                || ( radius > 0
-                && ( hasTransparentBlockAdjacent( world, position.east(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.west(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.up(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.down(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.south(), radius - 1 )
-                || hasTransparentBlockAdjacent( world, position.north(), radius - 1 ) ) );
-    }
-
-    private static boolean isSolidBlock(Block block) {
-        // Mob spawners are treated as solid blocks as far as the
-        // game is concerned for lighting and other tasks but for
-        // rendering they can be seen through therefor we special
-        // case them so that the antixray doesn't show the fake
-        // blocks around them.
-        return block.isOccluding() && block != Blocks.MOB_SPAWNER;
-    }
-}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index ab2f8bf..c436ee1 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -2,6 +2,14 @@ package org.spigotmc;
 
 import java.util.Arrays;
 import java.util.List;
+
+// TacoSpigot start
+import net.techcable.tacospigot.xray.AntiXray;
+import net.techcable.tacospigot.xray.AntiXRayEngine;
+import net.techcable.tacospigot.xray.SpigotAntiXray;
+// TacoSpigot end
+
+
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
@@ -221,6 +229,7 @@ public class SpigotWorldConfig
     public List<Integer> hiddenBlocks;
     public List<Integer> replaceBlocks;
     public AntiXray antiXrayInstance;
+    public AntiXRayEngine defaultAntiXray; // TacoSpigot
     private void antiXray()
     {
         antiXray = getBoolean( "anti-xray.enabled", true );
@@ -245,7 +254,10 @@ public class SpigotWorldConfig
         } ) );
         log( "\tReplace Blocks: " + replaceBlocks );
 
-        antiXrayInstance = new AntiXray( this );
+        // TacoSpigot start
+        defaultAntiXray = antiXray ? new SpigotAntiXray(this) : null;
+        antiXrayInstance = new AntiXray(defaultAntiXray);
+        // TacoSpigot end
     }
 
     public boolean zombieAggressiveTowardsVillager;
-- 
2.4.6.windows.1

