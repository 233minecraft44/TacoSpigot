From d2e0aebe7b9eb5efaa96931d6f3d54e97d82a9f9 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Sat, 5 Sep 2015 18:38:09 -0700
Subject: [PATCH] Optimize world.getType() and world.getChunkAt()

Speeds up world.isValidPosition() by only checking for a valid y.
Checks for valid x and zs are only performed when chunks are (attempting)
loading.
Some minor optimizations to Chunk.getBlockData() and World.getChunkAt()

Should help with everything from redstone to entities.

diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index e0bc8aa..5284187 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -507,7 +507,7 @@ public class Chunk {
     }
 
     public IBlockData getBlockData(final BlockPosition blockposition) {
-        if (this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+        if (false /* this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES*/) { // TacoSpigot - never 'DEBUG_ALL_BLOCK_STATES'
             IBlockData iblockdata = null;
 
             if (blockposition.getY() == 60) {
@@ -521,7 +521,8 @@ public class Chunk {
             return iblockdata == null ? Blocks.AIR.getBlockData() : iblockdata;
         } else {
             try {
-                if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
+                // TacoSpigot - assume the 'y' is a valid position (usually true due to a World.isValidPosition check)
+                // if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
                     ChunkSection chunksection = this.sections[blockposition.getY() >> 4];
 
                     if (chunksection != null) {
@@ -530,9 +531,11 @@ public class Chunk {
                         int k = blockposition.getZ() & 15;
 
                         return chunksection.getType(i, j, k);
-                    }
-                }
-
+                        // TacoSpigot start
+                    } else return Blocks.AIR.getBlockData();
+                // }
+                // TacoSpigot end
+            } catch (IndexOutOfBoundsException e) { // TacoSpigot - handle cases where blockposition.getY() is not valid
                 return Blocks.AIR.getBlockData();
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 0e6a37f..e6df9d8 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -114,9 +114,15 @@ public class ChunkProviderServer implements IChunkProvider {
         return getChunkAt(i, j, null);
     }
 
+    // TacoSpigot start - cache the most recently returned chunk
+    private Chunk lastChunk = null;
     public Chunk getChunkAt(int i, int j, Runnable runnable) {
+        if (lastChunk != null && lastChunk.locX == i && lastChunk.locZ == j) return lastChunk;
+        // TacoSpigot end
         unloadQueue.remove(i, j);
         Chunk chunk = chunks.get(LongHash.toLong(i, j));
+        if (chunk == null) { // TacoSpigot - optimize cases where the chunk is in the map
+        if (!World.isValidChunk(i, j)) throw new IllegalArgumentException("Invalid chunk position " + i + " " + j); // TacoSpigot - throw IllegalArgumentException instead of loading a invalid chunk
         ChunkRegionLoader loader = null;
 
         if (this.chunkLoader instanceof ChunkRegionLoader) {
@@ -124,22 +130,24 @@ public class ChunkProviderServer implements IChunkProvider {
 
         }
         // We can only use the queue for already generated chunks
-        if (chunk == null && loader != null && loader.chunkExists(world, i, j)) {
+        if (loader != null && loader.chunkExists(world, i, j)) { // TacoSpigot
             if (runnable != null) {
                 ChunkIOExecutor.queueChunkLoad(world, loader, this, i, j, runnable);
                 return null;
             } else {
                 chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
             }
-        } else if (chunk == null) {
+        } else { // TacoSpigot
             chunk = originalGetChunkAt(i, j);
         }
+        } // TacoSpigot - close 'if (chunk == null)
 
         // If we didn't load the chunk async and have a callback run it now
         if (runnable != null) {
             runnable.run();
         }
 
+        lastChunk = chunk; // TacoSpigot - cache the chunk
         return chunk;
     }
     public Chunk originalGetChunkAt(int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 158646b..171fa28 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -28,6 +28,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
     // CraftBukkit start
     public boolean chunkExists(World world, int i, int j) {
+        if (!World.isValidChunk(i, j)) return false; // TacoSpigot - ensure valid
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
         if (this.c.contains(chunkcoordintpair)) {
@@ -56,6 +57,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
     }
 
     public Object[] loadChunk(World world, int i, int j) throws IOException {
+        if (!World.isValidChunk(i, j)) return null; // TacoSpigot - ensure valid
         // CraftBukkit end
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
         NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.get(chunkcoordintpair);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 7b67e18..6d9d592 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -297,9 +297,23 @@ public abstract class World implements IBlockAccess {
         return this.getType(blockposition1).getBlock();
     }
 
-    private boolean isValidLocation(BlockPosition blockposition) {
-        return blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 && blockposition.getY() >= 0 && blockposition.getY() < 256;
+    // TacoSpigot - start optimize isValidLocation
+    /* We check for a valid x and z in loadChunk() by calling isValidChunk
+     * This means we never load an invalid chunk, and avoid a check for invalid chunks for getting from the hash map
+     * In addition, since chunk positions are smaller (by 16 times), bitwise comparisons should be faster
+     * Also we make it static to inline it easier
+     * Make sure to update isValidChunk() whenever isValidLocation() changes
+     */
+    public static boolean isValidLocation(BlockPosition blockposition) {
+        return /*blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 &&*/ blockposition.getY() >= 0 && blockposition.getY() < 256;
+    }
+
+    private static final int MIN_CHUNK_XZ =  -30000000 >> 4;
+    private static final int MAX_CHUNK_XZ = 30000000 >> 4; // You have to do a '<' check here instead of a '<=' check (IDK why)
+    public static boolean isValidChunk(int x, int z) {
+        return x >= MIN_CHUNK_XZ && z >= MIN_CHUNK_XZ && x < MAX_CHUNK_XZ && z < MAX_CHUNK_XZ;
     }
+    // TacoSpigot end
 
     public boolean isEmpty(BlockPosition blockposition) {
         return this.getType(blockposition).getBlock().getMaterial() == Material.AIR;
@@ -796,9 +810,15 @@ public abstract class World implements IBlockAccess {
         if (!this.isValidLocation(blockposition)) {
             return Blocks.AIR.getBlockData();
         } else {
+            // TacoSpigot start - handle invalid chunk positions
+            try {
             Chunk chunk = this.getChunkAtWorldCoords(blockposition);
 
             return chunk.getBlockData(blockposition);
+            } catch (IllegalArgumentException e) {
+                return Blocks.AIR.getBlockData();
+            }
+            // TacoSpigot end
         }
     }
 
-- 
2.5.2.windows.2

