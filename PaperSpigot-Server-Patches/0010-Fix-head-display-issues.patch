From 6d54d0be88218f1c4cc21309826f36ce46bd0abe Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Fri, 7 Aug 2015 19:31:31 -0700
Subject: [PATCH] Fix head display issues

Update head skins (disabled by default)
Send a packet to the client when the head type changes
Log issues with head lookups.

diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 25410f8..d4b8ab3 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -271,9 +271,14 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
                     if (this.getItem(i) != null) {
                         ItemStack itemstack = this.getItem(i).cloneItemStack();
                         // ItemStack itemstack1 = addItem(iinventory, this.splitStack(i, 1), enumdirection);
-
+                        // TacoSpigot start - add an option to turn of InventoryMoveItemEvent
+                        InventoryMoveItemEvent event = null;
+                        CraftItemStack oitemstack = null;
+                        ItemStack nmsOriginalItemStack = this.splitStack(i, world.spigotConfig.hopperAmount);
+                        if (HopperHelper.isFireInventoryMoveItemEvent(this)) {
                         // CraftBukkit start - Call event when pushing items into other inventories
-                        CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.splitStack(i, world.spigotConfig.hopperAmount)); // Spigot
+                        oitemstack = CraftItemStack.asCraftMirror(nmsOriginalItemStack);
+                        // TacoSpigot end
 
                         Inventory destinationInventory;
                         // Have to special case large chests as they work oddly
@@ -283,18 +288,21 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
                             destinationInventory = iinventory.getOwner().getInventory();
                         }
 
-                        InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
+                        event = new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true); // TacoSpigot - declare event above
                         this.getWorld().getServer().getPluginManager().callEvent(event);
                         if (event.isCancelled()) {
                             this.setItem(i, itemstack);
                             this.d(world.spigotConfig.hopperTransfer); // Spigot
                             return false;
                         }
-                        int origCount = event.getItem().getAmount(); // Spigot
-                        ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(event.getItem()), enumdirection);
+                        // TacoSpigot start - handle cases where the event is not fired
+                        }
+                        int origCount = event != null ? event.getItem().getAmount() : nmsOriginalItemStack.count; // Spigot
+                        ItemStack itemstack1 = addItem(iinventory, event != null ? CraftItemStack.asNMSCopy(event.getItem()) : nmsOriginalItemStack, enumdirection);
+                        // TacoSpigot end
 
                         if (itemstack1 == null || itemstack1.count == 0) {
-                            if (event.getItem().equals(oitemstack)) {
+                            if (event == null || event.getItem().equals(oitemstack)) { // TacoSpigot - handle whenever the event wasn't fired
                                 iinventory.update();
                             } else {
                                 this.setItem(i, itemstack);
@@ -426,8 +434,14 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         if (itemstack != null && b(iinventory, itemstack, i, enumdirection)) {
             ItemStack itemstack1 = itemstack.cloneItemStack();
             // ItemStack itemstack2 = addItem(ihopper, iinventory.splitStack(i, 1), (EnumDirection) null);
+            // TacoSpigot start - add an option to turn of InventoryMoveItemEvent
+            InventoryMoveItemEvent event = null;
+            CraftItemStack oitemstack = null;
+            ItemStack nmsOriginalItemStack = iinventory.splitStack(i, ihopper.getWorld().spigotConfig.hopperAmount);
+            if (HopperHelper.isFireInventoryMoveItemEvent(ihopper)) {
             // CraftBukkit start - Call event on collection of items from inventories into the hopper
-            CraftItemStack oitemstack = CraftItemStack.asCraftMirror(iinventory.splitStack(i, ihopper.getWorld().spigotConfig.hopperAmount)); // Spigot
+            oitemstack = CraftItemStack.asCraftMirror(nmsOriginalItemStack);
+            // TacoSpigot end
 
             Inventory sourceInventory;
             // Have to special case large chests as they work oddly
@@ -437,7 +451,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
                 sourceInventory = iinventory.getOwner().getInventory();
             }
 
-            InventoryMoveItemEvent event = new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), ihopper.getOwner().getInventory(), false);
+            event = new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), ihopper.getOwner().getInventory(), false); // TacoSpigot - declare above
 
             ihopper.getWorld().getServer().getPluginManager().callEvent(event);
             if (event.isCancelled()) {
@@ -452,9 +466,14 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
             }
             int origCount = event.getItem().getAmount(); // Spigot
             ItemStack itemstack2 = addItem(ihopper, CraftItemStack.asNMSCopy(event.getItem()), null);
+            // TacoSpigot start - handle cases where the event is not fired
+            }
+            int origCount = event != null ? event.getItem().getAmount() : nmsOriginalItemStack.count; // Spigot
+            ItemStack itemstack2 = addItem(ihopper, event != null ? CraftItemStack.asNMSCopy(event.getItem()) : nmsOriginalItemStack, null);
+            // TacoSpigot end
 
             if (itemstack2 == null || itemstack2.count == 0) {
-                if (event.getItem().equals(oitemstack)) {
+                if (event == null || event.getItem().equals(oitemstack)) { // TacoSpigot - handle when the event is not fired
                     iinventory.update();
                 } else {
                     iinventory.setItem(i, itemstack1);
diff --git a/src/main/java/net/minecraft/server/TileEntitySkull.java b/src/main/java/net/minecraft/server/TileEntitySkull.java
index 58014c5..62be623 100644
--- a/src/main/java/net/minecraft/server/TileEntitySkull.java
+++ b/src/main/java/net/minecraft/server/TileEntitySkull.java
@@ -18,18 +18,24 @@ import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.authlib.Agent;
 import com.mojang.authlib.ProfileLookupCallback;
 // Spigot end
+// TacoSpigot start
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.techcable.tacospigot.TacoSpigotConfig;
+// TacoSpigot end
 
 public class TileEntitySkull extends TileEntity {
 
     private int a;
     private int rotation;
-    private GameProfile g = null;
+    public GameProfile g = null; // TacoSpigot - make public
     // Spigot start
     public static final Executor executor = Executors.newFixedThreadPool(3,
             new ThreadFactoryBuilder()
                     .setNameFormat("Head Conversion Thread - %1$d")
                     .build()
     );
+    private static long lastMsg;// TacoSpigot
     public static final LoadingCache<String, GameProfile> skinCache = CacheBuilder.newBuilder()
             .maximumSize( 5000 )
             .expireAfterAccess( 60, TimeUnit.MINUTES )
@@ -48,12 +54,18 @@ public class TileEntitySkull extends TileEntity {
 
                         @Override
                         public void onProfileLookupFailed(GameProfile gp, Exception excptn) {
+                            // TacoSpigot start - log errors
+                            if (excptn != null && System.currentTimeMillis() - lastMsg > TimeUnit.MINUTES.toMillis(5)) {
+                                Logger logger = Logger.getLogger("");
+                                logger.log(Level.WARNING, "Unable to lookup profile", excptn);
+                                lastMsg = System.currentTimeMillis();
+                            }
+                            // TacoSpigot end
                             profiles[0] = gp;
                         }
                     };
 
                     MinecraftServer.getServer().getGameProfileRepository().findProfilesByNames(new String[] { key }, Agent.MINECRAFT, gameProfileLookup);
-
                     GameProfile profile = profiles[ 0 ];
                     if (profile == null) {
                         UUID uuid = EntityHuman.a(new GameProfile(null, key));
@@ -100,6 +112,7 @@ public class TileEntitySkull extends TileEntity {
         if (this.a == 3) {
             if (nbttagcompound.hasKeyOfType("Owner", 10)) {
                 this.g = GameProfileSerializer.deserialize(nbttagcompound.getCompound("Owner"));
+
             } else if (nbttagcompound.hasKeyOfType("ExtraType", 8)) {
                 String s = nbttagcompound.getString("ExtraType");
 
@@ -138,6 +151,7 @@ public class TileEntitySkull extends TileEntity {
         // Spigot start
         GameProfile profile = this.g;
         setSkullType( 0 ); // Work around client bug
+        update(); // TacoSpigot - update so that clients see the new skull type
         b(profile, new Predicate<GameProfile>() {
 
             @Override
@@ -203,4 +217,11 @@ public class TileEntitySkull extends TileEntity {
         return this.rotation;
     }
     // CraftBukkit end
+    // TacoSpigot start
+    @Override
+    public void D() { // setValid()
+        super.D();
+        if (TacoSpigotConfig.headUpdateQueue != null) TacoSpigotConfig.headUpdateQueue.queueUpdate(this);
+    }
+    // TacoSpigot
 }
diff --git a/src/main/java/net/techcable/tacospigot/HeadUpdateQueue.java b/src/main/java/net/techcable/tacospigot/HeadUpdateQueue.java
new file mode 100644
index 0000000..009e38c
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/HeadUpdateQueue.java
@@ -0,0 +1,98 @@
+package net.techcable.tacospigot;
+
+import java.lang.ref.WeakReference;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import com.mojang.authlib.GameProfile;
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.TileEntitySkull;
+import net.minecraft.server.World;
+
+public class HeadUpdateQueue implements Runnable {
+
+    @Override
+    public void run() {
+        while (true) {
+            QueuedHead head = headQueue.poll();
+            if (!head.canUpdate()) {
+                if (!hasValidHeads()) { // Prevent busy waiting when there aren't valid heads
+                    try {
+                        Thread.sleep(100);
+                    } catch (InterruptedException e) {}
+                }
+                queueLater(head);
+                continue;
+            }
+            GameProfile profile = MinecraftServer.getServer().aD().fillProfileProperties(head.getProfile(), true);
+            if (profile == null) {
+                queueLater(head);
+                continue;
+            }
+            MinecraftServer.getServer().processQueue.add(() -> {
+                TileEntitySkull tile = head.getTile();
+                if (tile == null) return; // Meh
+                World world = tile.getWorld();
+                tile.setSkullType(0);
+                tile.update(); // Update with skull type 0
+                tile.setSkullType(3);
+                tile.g = profile;
+                tile.update();
+                if (world != null) {
+                    world.notify(tile.getPosition());
+                }
+            });
+        }
+    }
+
+    private boolean hasValidHeads() {
+        if (headQueue.isEmpty()) return false;
+        for (QueuedHead head : headQueue) {
+            if (head.isValid()) return true;
+        }
+        return false;
+    }
+
+    private final BlockingQueue<QueuedHead> headQueue = new LinkedBlockingQueue<>();
+
+    public void queueUpdate(TileEntitySkull skull) {
+        queueUpdate(new QueuedHead(skull));
+    }
+
+    public void queueUpdate(QueuedHead head) {
+        if (!head.isValid()) return;
+        headQueue.add(head);
+    }
+
+    public void queueLater(QueuedHead head) {
+        head.updateTime = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(70); // Try again in just over a minute
+        queueUpdate(head);
+    }
+
+    private class QueuedHead {
+        private final WeakReference<TileEntitySkull> skullRef;
+        private long updateTime = -1;
+
+        public QueuedHead(TileEntitySkull skull) {
+            this.skullRef = new WeakReference<TileEntitySkull>(skull);
+        }
+
+        public TileEntitySkull getTile() {
+            return skullRef.get();
+        }
+
+        public GameProfile getProfile() {
+            return getTile() == null ? null : new GameProfile(getTile().getGameProfile().getId(), getTile().getGameProfile().getName());
+        }
+
+        public boolean isValid() {
+            return getTile() != null && getProfile() != null && getProfile().getId() != null;
+        }
+
+        public boolean canUpdate() {
+            return isValid() && updateTime <= System.currentTimeMillis();
+        }
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/HopperHelper.java b/src/main/java/net/techcable/tacospigot/HopperHelper.java
index 43e8953..4f42177 100644
--- a/src/main/java/net/techcable/tacospigot/HopperHelper.java
+++ b/src/main/java/net/techcable/tacospigot/HopperHelper.java
@@ -9,6 +9,7 @@ import net.minecraft.server.ChunkSection;
 import net.minecraft.server.Entity;
 import net.minecraft.server.EntityItem;
 import net.minecraft.server.IBlockData;
+import net.minecraft.server.IHopper;
 import net.minecraft.server.IInventory;
 import net.minecraft.server.InventoryLargeChest;
 import net.minecraft.server.MathHelper;
@@ -19,6 +20,7 @@ import net.minecraft.server.World;
 import net.techcable.tacospigot.utils.BlockHelper;
 
 import org.bukkit.Material;
+import org.bukkit.event.inventory.InventoryMoveItemEvent;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -130,4 +132,7 @@ public class HopperHelper {
         return positions;
     }
 
+    public static boolean isFireInventoryMoveItemEvent(IHopper hopper) {
+        return hopper.getWorld().tacoSpigotConfig.isHopperFireIMIE && InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length > 0;
+    }
 }
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
index 44ea98d..31cdb10 100644
--- a/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
@@ -5,15 +5,10 @@ import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.logging.Level;
 
-import net.minecraft.server.MinecraftServer;
-
 import org.bukkit.Bukkit;
-import org.bukkit.command.Command;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 
@@ -107,4 +102,14 @@ public class TacoSpigotConfig {
     private static void dataWatcherWeaklyConsistent() {
         dataWatcherWeaklyConsistent = getBoolean("data-watcher.weakly-consistent", true);
     }
+
+    public static HeadUpdateQueue headUpdateQueue;
+    private static void headUpdateQueue() {
+        if (getBoolean("heads.update-heads", false)) {
+            headUpdateQueue = new HeadUpdateQueue();
+            Thread thread = new Thread(headUpdateQueue, "TacoSpigot Head Update Thread");
+            thread.setDaemon(true);
+            thread.start();
+        }
+    }
 }
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
index 469779f..58f335d 100644
--- a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
@@ -69,6 +69,11 @@ public class TacoSpigotWorldConfig {
         isHopperPushBased = getBoolean("hopper.push-based", true);
     }
 
+    public boolean isHopperFireIMIE;
+    private void isHopperFireIMIE() {
+        isHopperFireIMIE = getBoolean("hopper.fire-InventoryMoveItemEvent", true);
+    }
+
     public boolean optimizeArmorStandMovement;
     private void isArmorStandMoveWithoutGravity() {
         optimizeArmorStandMovement = getBoolean("armor-stand.optimize-movement", false); // Doesn't fully emulate vanilla behavior, see issue #1
-- 
2.6.1.windows.1

