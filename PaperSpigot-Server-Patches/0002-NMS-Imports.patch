From 3b66972a626dd6de28b42c92b0c36f29f9233cc2 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Sun, 16 Aug 2015 12:18:44 -0700
Subject: [PATCH] NMS Imports

This must be updated every version
Only use code decompiled with BuildTools

diff --git a/src/main/java/net/minecraft/server/BlockState.java b/src/main/java/net/minecraft/server/BlockState.java
new file mode 100644
index 0000000..3cada5a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockState.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+import com.google.common.base.Objects;
+
+public abstract class BlockState<T extends Comparable<T>> implements IBlockState<T> {
+
+    private final Class<T> a;
+    private final String b;
+
+    protected BlockState(String s, Class<T> oclass) {
+        this.a = oclass;
+        this.b = s;
+    }
+
+    public String a() {
+        return this.b;
+    }
+
+    public Class<T> b() {
+        return this.a;
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("name", this.b).add("clazz", this.a).add("values", this.c()).toString();
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (object != null && this.getClass() == object.getClass()) {
+            BlockState blockstate = (BlockState) object;
+
+            return this.a.equals(blockstate.a) && this.b.equals(blockstate.b);
+        } else {
+            return false;
+        }
+    }
+
+    public int hashCode() {
+        return 31 * this.a.hashCode() + this.b.hashCode();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStateBoolean.java b/src/main/java/net/minecraft/server/BlockStateBoolean.java
new file mode 100644
index 0000000..7fb0960
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStateBoolean.java
@@ -0,0 +1,29 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Collection;
+
+public class BlockStateBoolean extends BlockState<Boolean> {
+
+    private final ImmutableSet<Boolean> a = ImmutableSet.of(Boolean.valueOf(true), Boolean.valueOf(false));
+
+    protected BlockStateBoolean(String s) {
+        super(s, Boolean.class);
+    }
+
+    public Collection<Boolean> c() {
+        return this.a;
+    }
+
+    public static BlockStateBoolean of(String s) {
+        return new BlockStateBoolean(s);
+    }
+
+    public String a(Boolean obool) {
+        return obool.toString();
+    }
+
+    public String a(Comparable comparable) {
+        return this.a((Boolean) comparable);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStateEnum.java b/src/main/java/net/minecraft/server/BlockStateEnum.java
new file mode 100644
index 0000000..0b555df
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStateEnum.java
@@ -0,0 +1,63 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.Collections2;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+
+public class BlockStateEnum<T extends Enum<T> & INamable> extends BlockState<T> {
+
+    private final ImmutableSet<T> a;
+    private final Map<String, T> b = Maps.newHashMap();
+
+    protected BlockStateEnum(String s, Class<T> oclass, Collection<T> collection) {
+        super(s, oclass);
+        this.a = ImmutableSet.copyOf(collection);
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            Enum oenum = (Enum) iterator.next();
+            String s1 = ((INamable) oenum).getName();
+
+            if (this.b.containsKey(s1)) {
+                throw new IllegalArgumentException("Multiple values have the same name \'" + s1 + "\'");
+            }
+
+            this.b.put(s1, oenum);
+        }
+
+    }
+
+    public Collection<T> c() {
+        return this.a;
+    }
+
+    public String a(T t0) {
+        return ((INamable) t0).getName();
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass) {
+        return a(s, oclass, Predicates.alwaysTrue());
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass, Predicate<T> predicate) {
+        return a(s, oclass, Collections2.filter(Lists.newArrayList(oclass.getEnumConstants()), predicate));
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass, T... at) {
+        return a(s, oclass, (Collection) Lists.newArrayList(at));
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass, Collection<T> collection) {
+        return new BlockStateEnum(s, oclass, collection);
+    }
+
+    public String a(Comparable comparable) {
+        return this.a((Enum) comparable);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStateInteger.java b/src/main/java/net/minecraft/server/BlockStateInteger.java
new file mode 100644
index 0000000..4e7e489
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStateInteger.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.HashSet;
+
+public class BlockStateInteger extends BlockState<Integer> {
+
+    private final ImmutableSet<Integer> a;
+
+    protected BlockStateInteger(String s, int i, int j) {
+        super(s, Integer.class);
+        if (i < 0) {
+            throw new IllegalArgumentException("Min value of " + s + " must be 0 or greater");
+        } else if (j <= i) {
+            throw new IllegalArgumentException("Max value of " + s + " must be greater than min (" + i + ")");
+        } else {
+            HashSet hashset = Sets.newHashSet();
+
+            for (int k = i; k <= j; ++k) {
+                hashset.add(Integer.valueOf(k));
+            }
+
+            this.a = ImmutableSet.copyOf(hashset);
+        }
+    }
+
+    public Collection<Integer> c() {
+        return this.a;
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (object != null && this.getClass() == object.getClass()) {
+            if (!super.equals(object)) {
+                return false;
+            } else {
+                BlockStateInteger blockstateinteger = (BlockStateInteger) object;
+
+                return this.a.equals(blockstateinteger.a);
+            }
+        } else {
+            return false;
+        }
+    }
+
+    public int hashCode() {
+        int i = super.hashCode();
+
+        i = 31 * i + this.a.hashCode();
+        return i;
+    }
+
+    public static BlockStateInteger of(String s, int i, int j) {
+        return new BlockStateInteger(s, i, j);
+    }
+
+    public String a(Integer integer) {
+        return integer.toString();
+    }
+
+    public String a(Comparable comparable) {
+        return this.a((Integer) comparable);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStateList.java b/src/main/java/net/minecraft/server/BlockStateList.java
new file mode 100644
index 0000000..8a815a6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStateList.java
@@ -0,0 +1,191 @@
+package net.minecraft.server;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableTable;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+public class BlockStateList {
+
+    private static final Joiner a = Joiner.on(", ");
+    private static final Function<IBlockState, String> b = new Function() {
+        public String a(IBlockState iblockstate) {
+            return iblockstate == null ? "<NULL>" : iblockstate.a();
+        }
+
+        public Object apply(Object object) {
+            return this.a((IBlockState) object);
+        }
+    };
+    private final Block c;
+    private final ImmutableList<IBlockState> d;
+    private final ImmutableList<IBlockData> e;
+
+    public BlockStateList(Block block, IBlockState... aiblockstate) {
+        this.c = block;
+        Arrays.sort(aiblockstate, new Comparator() {
+            public int a(IBlockState iblockstate, IBlockState iblockstate1) {
+                return iblockstate.a().compareTo(iblockstate1.a());
+            }
+
+            public int compare(Object object, Object object1) {
+                return this.a((IBlockState) object, (IBlockState) object1);
+            }
+        });
+        this.d = ImmutableList.copyOf(aiblockstate);
+        LinkedHashMap linkedhashmap = Maps.newLinkedHashMap();
+        ArrayList arraylist = Lists.newArrayList();
+        Iterable iterable = IteratorUtils.a(this.e());
+        Iterator iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            List list = (List) iterator.next();
+            Map map = MapGeneratorUtils.b(this.d, list);
+            BlockStateList.BlockData blockstatelist_blockdata = new BlockStateList.BlockData(block, ImmutableMap.copyOf(map), null);
+
+            linkedhashmap.put(map, blockstatelist_blockdata);
+            arraylist.add(blockstatelist_blockdata);
+        }
+
+        iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            BlockStateList.BlockData blockstatelist_blockdata1 = (BlockStateList.BlockData) iterator.next();
+
+            blockstatelist_blockdata1.a((Map) linkedhashmap);
+        }
+
+        this.e = ImmutableList.copyOf(arraylist);
+    }
+
+    public ImmutableList<IBlockData> a() {
+        return this.e;
+    }
+
+    private List<Iterable<Comparable>> e() {
+        ArrayList arraylist = Lists.newArrayList();
+
+        for (int i = 0; i < this.d.size(); ++i) {
+            arraylist.add(((IBlockState) this.d.get(i)).c());
+        }
+
+        return arraylist;
+    }
+
+    public IBlockData getBlockData() {
+        return (IBlockData) this.e.get(0);
+    }
+
+    public Block getBlock() {
+        return this.c;
+    }
+
+    public Collection<IBlockState> d() {
+        return this.d;
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("block", Block.REGISTRY.c(this.c)).add("properties", Iterables.transform(this.d, BlockStateList.b)).toString();
+    }
+
+    static class BlockData extends BlockDataAbstract {
+
+        private final Block a;
+        private final ImmutableMap<IBlockState, Comparable> b;
+        private ImmutableTable<IBlockState, Comparable, IBlockData> c;
+
+        private BlockData(Block block, ImmutableMap<IBlockState, Comparable> immutablemap) {
+            this.a = block;
+            this.b = immutablemap;
+        }
+
+        public Collection<IBlockState> a() {
+            return Collections.unmodifiableCollection(this.b.keySet());
+        }
+
+        public <T extends Comparable<T>> T get(IBlockState<T> iblockstate) {
+            if (!this.b.containsKey(iblockstate)) {
+                throw new IllegalArgumentException("Cannot get property " + iblockstate + " as it does not exist in " + this.a.P());
+            } else {
+                return (Comparable) iblockstate.b().cast(this.b.get(iblockstate));
+            }
+        }
+
+        public <T extends Comparable<T>, V extends T> IBlockData set(IBlockState<T> iblockstate, V v0) {
+            if (!this.b.containsKey(iblockstate)) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " as it does not exist in " + this.a.P());
+            } else if (!iblockstate.c().contains(v0)) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " to " + v0 + " on block " + Block.REGISTRY.c(this.a) + ", it is not an allowed value");
+            } else {
+                return (IBlockData) (this.b.get(iblockstate) == v0 ? this : (IBlockData) this.c.get(iblockstate, v0));
+            }
+        }
+
+        public ImmutableMap<IBlockState, Comparable> b() {
+            return this.b;
+        }
+
+        public Block getBlock() {
+            return this.a;
+        }
+
+        public boolean equals(Object object) {
+            return this == object;
+        }
+
+        public int hashCode() {
+            return this.b.hashCode();
+        }
+
+        public void a(Map<Map<IBlockState, Comparable>, BlockStateList.BlockData> map) {
+            if (this.c != null) {
+                throw new IllegalStateException();
+            } else {
+                HashBasedTable hashbasedtable = HashBasedTable.create();
+                Iterator iterator = this.b.keySet().iterator();
+
+                while (iterator.hasNext()) {
+                    IBlockState iblockstate = (IBlockState) iterator.next();
+                    Iterator iterator1 = iblockstate.c().iterator();
+
+                    while (iterator1.hasNext()) {
+                        Comparable comparable = (Comparable) iterator1.next();
+
+                        if (comparable != this.b.get(iblockstate)) {
+                            hashbasedtable.put(iblockstate, comparable, map.get(this.b(iblockstate, comparable)));
+                        }
+                    }
+                }
+
+                this.c = ImmutableTable.copyOf(hashbasedtable);
+            }
+        }
+
+        private Map<IBlockState, Comparable> b(IBlockState iblockstate, Comparable comparable) {
+            HashMap hashmap = Maps.newHashMap(this.b);
+
+            hashmap.put(iblockstate, comparable);
+            return hashmap;
+        }
+
+        BlockData(Block block, ImmutableMap immutablemap, Object object) {
+            this(block, immutablemap);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityTypes.java b/src/main/java/net/minecraft/server/EntityTypes.java
new file mode 100644
index 0000000..064d0b2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityTypes.java
@@ -0,0 +1,244 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class EntityTypes {
+
+    private static final Logger b = LogManager.getLogger();
+    private static final Map<String, Class<? extends Entity>> c = Maps.newHashMap();
+    private static final Map<Class<? extends Entity>, String> d = Maps.newHashMap();
+    private static final Map<Integer, Class<? extends Entity>> e = Maps.newHashMap();
+    private static final Map<Class<? extends Entity>, Integer> f = Maps.newHashMap();
+    private static final Map<String, Integer> g = Maps.newHashMap();
+    public static final Map<Integer, EntityTypes.MonsterEggInfo> eggInfo = Maps.newLinkedHashMap();
+
+    private static void a(Class<? extends Entity> oclass, String s, int i) {
+        if (EntityTypes.c.containsKey(s)) {
+            throw new IllegalArgumentException("ID is already registered: " + s);
+        } else if (EntityTypes.e.containsKey(Integer.valueOf(i))) {
+            throw new IllegalArgumentException("ID is already registered: " + i);
+        } else if (i == 0) {
+            throw new IllegalArgumentException("Cannot register to reserved id: " + i);
+        } else if (oclass == null) {
+            throw new IllegalArgumentException("Cannot register null clazz for id: " + i);
+        } else {
+            EntityTypes.c.put(s, oclass);
+            EntityTypes.d.put(oclass, s);
+            EntityTypes.e.put(Integer.valueOf(i), oclass);
+            EntityTypes.f.put(oclass, Integer.valueOf(i));
+            EntityTypes.g.put(s, Integer.valueOf(i));
+        }
+    }
+
+    private static void a(Class<? extends Entity> oclass, String s, int i, int j, int k) {
+        a(oclass, s, i);
+        EntityTypes.eggInfo.put(Integer.valueOf(i), new EntityTypes.MonsterEggInfo(i, j, k));
+    }
+
+    public static Entity createEntityByName(String s, World world) {
+        Entity entity = null;
+
+        try {
+            Class oclass = (Class) EntityTypes.c.get(s);
+
+            if (oclass != null) {
+                entity = (Entity) oclass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+        return entity;
+    }
+
+    public static Entity a(NBTTagCompound nbttagcompound, World world) {
+        Entity entity = null;
+
+        if ("Minecart".equals(nbttagcompound.getString("id"))) {
+            nbttagcompound.setString("id", EntityMinecartAbstract.EnumMinecartType.a(nbttagcompound.getInt("Type")).b());
+            nbttagcompound.remove("Type");
+        }
+
+        try {
+            Class oclass = (Class) EntityTypes.c.get(nbttagcompound.getString("id"));
+
+            if (oclass != null) {
+                entity = (Entity) oclass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+        if (entity != null) {
+            entity.f(nbttagcompound);
+        } else {
+            EntityTypes.b.warn("Skipping Entity with id " + nbttagcompound.getString("id"));
+        }
+
+        return entity;
+    }
+
+    public static Entity a(int i, World world) {
+        Entity entity = null;
+
+        try {
+            Class oclass = a(i);
+
+            if (oclass != null) {
+                entity = (Entity) oclass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+        if (entity == null) {
+            EntityTypes.b.warn("Skipping Entity with id " + i);
+        }
+
+        return entity;
+    }
+
+    public static int a(Entity entity) {
+        Integer integer = (Integer) EntityTypes.f.get(entity.getClass());
+
+        return integer == null ? 0 : integer.intValue();
+    }
+
+    public static Class<? extends Entity> a(int i) {
+        return (Class) EntityTypes.e.get(Integer.valueOf(i));
+    }
+
+    public static String b(Entity entity) {
+        return (String) EntityTypes.d.get(entity.getClass());
+    }
+
+    public static String b(int i) {
+        return (String) EntityTypes.d.get(a(i));
+    }
+
+    public static void a() {}
+
+    public static List<String> b() {
+        Set set = EntityTypes.c.keySet();
+        ArrayList arraylist = Lists.newArrayList();
+        Iterator iterator = set.iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            Class oclass = (Class) EntityTypes.c.get(s);
+
+            if ((oclass.getModifiers() & 1024) != 1024) {
+                arraylist.add(s);
+            }
+        }
+
+        arraylist.add("LightningBolt");
+        return arraylist;
+    }
+
+    public static boolean a(Entity entity, String s) {
+        String s1 = b(entity);
+
+        if (s1 == null && entity instanceof EntityHuman) {
+            s1 = "Player";
+        } else if (s1 == null && entity instanceof EntityLightning) {
+            s1 = "LightningBolt";
+        }
+
+        return s.equals(s1);
+    }
+
+    public static boolean b(String s) {
+        return "Player".equals(s) || b().contains(s);
+    }
+
+    static {
+        a(EntityItem.class, "Item", 1);
+        a(EntityExperienceOrb.class, "XPOrb", 2);
+        a(EntityEgg.class, "ThrownEgg", 7);
+        a(EntityLeash.class, "LeashKnot", 8);
+        a(EntityPainting.class, "Painting", 9);
+        a(EntityArrow.class, "Arrow", 10);
+        a(EntitySnowball.class, "Snowball", 11);
+        a(EntityLargeFireball.class, "Fireball", 12);
+        a(EntitySmallFireball.class, "SmallFireball", 13);
+        a(EntityEnderPearl.class, "ThrownEnderpearl", 14);
+        a(EntityEnderSignal.class, "EyeOfEnderSignal", 15);
+        a(EntityPotion.class, "ThrownPotion", 16);
+        a(EntityThrownExpBottle.class, "ThrownExpBottle", 17);
+        a(EntityItemFrame.class, "ItemFrame", 18);
+        a(EntityWitherSkull.class, "WitherSkull", 19);
+        a(EntityTNTPrimed.class, "PrimedTnt", 20);
+        a(EntityFallingBlock.class, "FallingSand", 21);
+        a(EntityFireworks.class, "FireworksRocketEntity", 22);
+        a(EntityArmorStand.class, "ArmorStand", 30);
+        a(EntityBoat.class, "Boat", 41);
+        a(EntityMinecartRideable.class, EntityMinecartAbstract.EnumMinecartType.RIDEABLE.b(), 42);
+        a(EntityMinecartChest.class, EntityMinecartAbstract.EnumMinecartType.CHEST.b(), 43);
+        a(EntityMinecartFurnace.class, EntityMinecartAbstract.EnumMinecartType.FURNACE.b(), 44);
+        a(EntityMinecartTNT.class, EntityMinecartAbstract.EnumMinecartType.TNT.b(), 45);
+        a(EntityMinecartHopper.class, EntityMinecartAbstract.EnumMinecartType.HOPPER.b(), 46);
+        a(EntityMinecartMobSpawner.class, EntityMinecartAbstract.EnumMinecartType.SPAWNER.b(), 47);
+        a(EntityMinecartCommandBlock.class, EntityMinecartAbstract.EnumMinecartType.COMMAND_BLOCK.b(), 40);
+        a(EntityInsentient.class, "Mob", 48);
+        a(EntityMonster.class, "Monster", 49);
+        a(EntityCreeper.class, "Creeper", 50, 894731, 0);
+        a(EntitySkeleton.class, "Skeleton", 51, 12698049, 4802889);
+        a(EntitySpider.class, "Spider", 52, 3419431, 11013646);
+        a(EntityGiantZombie.class, "Giant", 53);
+        a(EntityZombie.class, "Zombie", 54, '\uafaf', 7969893);
+        a(EntitySlime.class, "Slime", 55, 5349438, 8306542);
+        a(EntityGhast.class, "Ghast", 56, 16382457, 12369084);
+        a(EntityPigZombie.class, "PigZombie", 57, 15373203, 5009705);
+        a(EntityEnderman.class, "Enderman", 58, 1447446, 0);
+        a(EntityCaveSpider.class, "CaveSpider", 59, 803406, 11013646);
+        a(EntitySilverfish.class, "Silverfish", 60, 7237230, 3158064);
+        a(EntityBlaze.class, "Blaze", 61, 16167425, 16775294);
+        a(EntityMagmaCube.class, "LavaSlime", 62, 3407872, 16579584);
+        a(EntityEnderDragon.class, "EnderDragon", 63);
+        a(EntityWither.class, "WitherBoss", 64);
+        a(EntityBat.class, "Bat", 65, 4996656, 986895);
+        a(EntityWitch.class, "Witch", 66, 3407872, 5349438);
+        a(EntityEndermite.class, "Endermite", 67, 1447446, 7237230);
+        a(EntityGuardian.class, "Guardian", 68, 5931634, 15826224);
+        a(EntityPig.class, "Pig", 90, 15771042, 14377823);
+        a(EntitySheep.class, "Sheep", 91, 15198183, 16758197);
+        a(EntityCow.class, "Cow", 92, 4470310, 10592673);
+        a(EntityChicken.class, "Chicken", 93, 10592673, 16711680);
+        a(EntitySquid.class, "Squid", 94, 2243405, 7375001);
+        a(EntityWolf.class, "Wolf", 95, 14144467, 13545366);
+        a(EntityMushroomCow.class, "MushroomCow", 96, 10489616, 12040119);
+        a(EntitySnowman.class, "SnowMan", 97);
+        a(EntityOcelot.class, "Ozelot", 98, 15720061, 5653556);
+        a(EntityIronGolem.class, "VillagerGolem", 99);
+        a(EntityHorse.class, "EntityHorse", 100, 12623485, 15656192);
+        a(EntityRabbit.class, "Rabbit", 101, 10051392, 7555121);
+        a(EntityVillager.class, "Villager", 120, 5651507, 12422002);
+        a(EntityEnderCrystal.class, "EnderCrystal", 200);
+    }
+
+    public static class MonsterEggInfo {
+
+        public final int a;
+        public final int b;
+        public final int c;
+        public final Statistic killEntityStatistic;
+        public final Statistic e;
+
+        public MonsterEggInfo(int i, int j, int k) {
+            this.a = i;
+            this.b = j;
+            this.c = k;
+            this.killEntityStatistic = StatisticList.a(this);
+            this.e = StatisticList.b(this);
+        }
+    }
+}
-- 
2.7.0

