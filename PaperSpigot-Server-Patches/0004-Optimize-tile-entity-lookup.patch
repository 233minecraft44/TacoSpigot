From c1f3221ed30b942ec34c18e1eba5d200de7135f6 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Sat, 25 Jul 2015 21:27:30 -0700
Subject: [PATCH] Optimize tile entity lookup

world.getTileEntity() iterates through all the tile entities in the world,which is replaced with a per-chunk map lookup.
Chunk tile entity lookup used to be a Map<BlockPosition, TileEntity>, which is inefficent as BlockPosition isn't designed for relative (to the chunk) position.
It is replaced with a TShortObjectHashMap which has no hash collisions, better hash distribution, and no object overhead.

diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index d5f13c0..b40eb95 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1,8 +1,8 @@
 package net.minecraft.server;
 
 import com.google.common.base.Predicate;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
@@ -13,12 +13,17 @@ import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger; // PaperSpigot
 
+import net.techcable.tacospigot.FakeTileEntityMap; // TacoSpigot
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
 import org.bukkit.Bukkit; // CraftBukkit
 
+import gnu.trove.map.hash.TShortObjectHashMap; // TacoSpigot
+import gnu.trove.map.TShortObjectMap; // TacoSpigot
+
 public class Chunk {
 
     private static final Logger c = LogManager.getLogger();
@@ -33,6 +38,41 @@ public class Chunk {
     public final int locZ;
     private boolean k;
     public final Map<BlockPosition, TileEntity> tileEntities;
+    // TacoSpigot Start - Optimize tile entity lookup
+    private final TShortObjectMap<TileEntity> tileEntitiesShort = new TShortObjectHashMap<TileEntity>();
+
+    public TileEntity getTileEntity(BlockPosition position) {
+        if (position == null) return null;
+        TileEntity tileEntity = tileEntitiesShort.get(toRelativeShort(position));
+        assert tileEntity != null && !tileEntity.getPosition().equals(position) : "tileEntitiesShort maps the tile entity at " + tileEntity.getPosition() + " to " + position;
+        return tileEntity;
+    }
+
+    public void addTileEntity(TileEntity entity) {
+        BlockPosition position = entity == null ? null : entity.getPosition();
+        if (position == null) return;
+        tileEntitiesShort.put(toRelativeShort(position), entity);
+    }
+
+    public TileEntity removeTileEntity(BlockPosition position) {
+        if (position == null) return null;
+        TileEntity tileEntity = tileEntitiesShort.remove(toRelativeShort(position));
+        assert tileEntity != null && !tileEntity.getPosition().equals(position) : "tileEntitiesShort maps the tile entity at " + tileEntity.getPosition() + " to " + position;
+        return tileEntity;
+    }
+
+    public static short toRelativeShort(BlockPosition pos) {
+        return (short)((pos.getX() & 0xF) | ((pos.getZ() & 0xF) << 4) | ((pos.getY() & 0xFF) << 8));
+    }
+
+    public static BlockPosition fromRelativeShort(int relative) {
+        int x = relative & 0xF;
+        int z = (relative >> 4) & 0xF;
+        int y = (relative >> 8) & 0xFF;
+        return new BlockPosition(x, y, z);
+    }
+
+    // TacoSpigot End
     public final List<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
@@ -126,7 +166,7 @@ public class Chunk {
         this.e = new byte[256];
         this.f = new int[256];
         this.g = new boolean[256];
-        this.tileEntities = Maps.newHashMap();
+        this.tileEntities = new FakeTileEntityMap(this, tileEntitiesShort); // TacoSpigot -- compensate for mojang's violation of encapsulation
         this.v = 4096;
         this.w = Queues.newConcurrentLinkedQueue();
         this.entitySlices = (List[]) (new List[16]); // Spigot
@@ -790,13 +830,17 @@ public class Chunk {
 
     public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
         // CraftBukkit start
-        TileEntity tileentity = null;
+        // TacoSpigot start - Optimize tile entity lookup
+        TileEntity tileentity = getTileEntity(blockposition);
+        /*
         if (world.captureBlockStates) {
             tileentity = world.capturedTileEntities.get(blockposition);
         }
         if (tileentity == null) {
             tileentity = (TileEntity) this.tileEntities.get(blockposition);
         }
+        */
+        // TacoSpigot end
         // CraftBukkit end
 
         if (tileentity == null) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 32c94f6..5b1db74 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1940,10 +1940,33 @@ public abstract class World implements IBlockAccess {
 
     public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
 
+    // TacoSpigot start - Optimize tile entity lookup
+    public TileEntity getTileEntityIfLoaded(BlockPosition position) {
+        Chunk chunk = getChunkIfLoaded(position.getX() >> 4, position.getZ() >> 4);
+        if (chunk == null) return null;
+        TileEntity tileEntity = chunk.getTileEntity(position);
+        if (tileEntity != null && tileEntity.x()) { // isInvalid
+            chunk.removeTileEntity(tileEntity.getPosition());
+            return null;
+        }
+        return tileEntity;
+    }
+    // TacoSpigot end
+
     public TileEntity getTileEntity(BlockPosition blockposition) {
         if (!this.isValidLocation(blockposition)) {
             return null;
         } else {
+            // TacoSpigot start -- Optimize tile entity lookup
+            Chunk chunk = getChunkAtWorldCoords(blockposition);
+            if (chunk == null) return null;
+            TileEntity tileEntity = chunk.getTileEntity(blockposition);
+            if (tileEntity != null && tileEntity.x()) {// isInvalid
+                chunk.removeTileEntity(tileEntity.getPosition());
+                return null;
+            }
+            return tileEntity;
+            /*
             // CraftBukkit start
             if (capturedTileEntities.containsKey(blockposition)) {
                 return capturedTileEntities.get(blockposition);
@@ -1979,6 +2002,8 @@ public abstract class World implements IBlockAccess {
             }
 
             return tileentity;
+            */
+            // TacoSpigot end
         }
     }
 
diff --git a/src/main/java/net/techcable/tacospigot/FakeTileEntityMap.java b/src/main/java/net/techcable/tacospigot/FakeTileEntityMap.java
new file mode 100644
index 0000000..996c22d
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/FakeTileEntityMap.java
@@ -0,0 +1,136 @@
+package net.techcable.tacospigot;
+
+import java.util.AbstractMap;
+import java.util.AbstractSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.TileEntity;
+
+import gnu.trove.iterator.TShortObjectIterator;
+import gnu.trove.map.TShortObjectMap;
+
+public class FakeTileEntityMap extends AbstractMap<BlockPosition, TileEntity> {
+    private final Chunk chunk;
+    private final TShortObjectMap<TileEntity> tileEntitiesShort;
+
+    public FakeTileEntityMap(Chunk chunk, TShortObjectMap<TileEntity> tileEntitiesShort) {
+        this.chunk = chunk;
+        this.tileEntitiesShort = tileEntitiesShort;
+    }
+
+    @Override
+    public int size() {
+        return tileEntitiesShort.size();
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        if (key == null || !(key instanceof BlockPosition)) return false;
+        return chunk.getTileEntity((BlockPosition) key) != null;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return tileEntitiesShort.containsValue(value);
+    }
+
+    @Override
+    public TileEntity get(Object key) {
+        if (key == null) return null;
+        return chunk.getTileEntity((BlockPosition) key);
+    }
+
+    @Override
+    public TileEntity put(BlockPosition key, TileEntity value) {
+        if (value == null) return chunk.removeTileEntity(key);
+        if (!value.getPosition().equals(key)) throw new IllegalStateException("Tried to add tile entity with thte position set to " + value.getPosition() + " to " + key);
+        TileEntity old = get(key);
+        chunk.addTileEntity(value);
+        return old;
+    }
+
+    @Override
+    public TileEntity remove(Object key) {
+        if (key == null) return null;
+        return chunk.removeTileEntity((BlockPosition) key);
+    }
+
+    @Override
+    public void clear() {
+        tileEntitiesShort.clear();
+    }
+
+    @Override
+    public Set<Entry<BlockPosition, TileEntity>> entrySet() {
+        return new AbstractSet<Entry<BlockPosition,TileEntity>>() {
+
+            @Override
+            public int size() {
+                return tileEntitiesShort.size();
+            }
+
+            @Override
+            public boolean contains(Object o) {
+                Map.Entry<BlockPosition, TileEntity> entry = (Map.Entry<BlockPosition, TileEntity>) o;
+                TileEntity tileEntity = FakeTileEntityMap.this.get(entry.getKey());
+                return tileEntity == null ? entry.getValue() == null : tileEntity.equals(entry.getValue());
+            }
+
+            @Override
+            public Iterator<Entry<BlockPosition, TileEntity>> iterator() {
+                final TShortObjectIterator<TileEntity> backing = tileEntitiesShort.iterator();
+                return new Iterator<Entry<BlockPosition, TileEntity>>() {
+
+
+                    @Override
+                    public boolean hasNext() {
+                        return backing.hasNext();
+                    }
+
+                    @Override
+                    public Entry<BlockPosition, TileEntity> next() {
+                        backing.advance();
+                        final short key = backing.key();
+                        return new Map.Entry<BlockPosition, TileEntity>() {
+
+                            @Override
+                            public BlockPosition getKey() {
+                                return Chunk.fromRelativeShort(key);
+                            }
+
+                            @Override
+                            public TileEntity getValue() {
+                                return FakeTileEntityMap.this.get(getKey());
+                            }
+
+                            @Override
+                            public TileEntity setValue(TileEntity value) {
+                                return FakeTileEntityMap.this.put(getKey(), value);
+                            }
+                        };
+                    }
+
+                    @Override
+                    public void remove() {
+                        backing.remove();
+                    }
+                };
+            }
+
+            @Override
+            public boolean remove(Object o) {
+                Map.Entry<BlockPosition, TileEntity> entry = (Map.Entry<BlockPosition, TileEntity>) o;
+                return FakeTileEntityMap.this.remove(entry.getKey(), entry.getValue());
+            }
+
+            @Override
+            public void clear() {
+                FakeTileEntityMap.this.clear();
+            }
+        };
+    }
+}
-- 
2.4.6.windows.1

