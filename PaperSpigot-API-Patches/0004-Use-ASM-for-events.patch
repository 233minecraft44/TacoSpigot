From e8159cc5e28f328647211c652793098a1fece9c9 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Tue, 1 Sep 2015 18:20:18 -0700
Subject: [PATCH] Use ASM for events


diff --git a/src/main/java/net/techcable/tacospigot/EventExecutorFactory.java b/src/main/java/net/techcable/tacospigot/EventExecutorFactory.java
new file mode 100644
index 0000000..2d41f62
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/EventExecutorFactory.java
@@ -0,0 +1,176 @@
+package net.techcable.tacospigot;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Type;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.objectweb.asm.Opcodes.*;
+
+public class EventExecutorFactory {
+    private EventExecutorFactory() {
+    }
+
+    public static final String INTERNAL_NAME = Type.getInternalName(EventExecutorFactory.class);
+    public static final String GENERATED_PACKAGE = INTERNAL_NAME.substring(0, INTERNAL_NAME.lastIndexOf('/')) + "/generated";
+    public static final String GENERATED_EXECUTOR_PREFIX = GENERATED_PACKAGE + "/GeneratedEventExecutor";
+
+    public static final Method EXECUTE_METHOD;
+    public static final String EXECUTE_DESCRIPTOR;
+
+    static {
+        try {
+            EXECUTE_METHOD = EventExecutor.class.getMethod("execute", Listener.class, Event.class);
+        } catch (NoSuchMethodException e) {
+            throw new AssertionError("Could not find execute(Listener, Event)V in EventExecutor");
+        }
+        EXECUTE_DESCRIPTOR = Type.getMethodDescriptor(EXECUTE_METHOD);
+    }
+
+    private static final AtomicInteger nextId = new AtomicInteger();
+
+    @sun.reflect.CallerSensitive
+    public static EventExecutor newASMEventExecutor(Method method, ClassLoader parent) {
+        validate(method);
+        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+        String name = GENERATED_EXECUTOR_PREFIX + nextId.incrementAndGet();
+        writer.visit(V1_6, ACC_PUBLIC, name, null, Type.getInternalName(Object.class), new String[]{EventExecutor.INTERNAL_NAME});
+        // Generate a constructor
+        MethodVisitor methodWriter = writer.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
+        methodWriter.visitCode();
+        methodWriter.visitVarInsn(ALOAD, 0); // Get this/super reference
+        methodWriter.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(Object.class), "<init>", "()V", false); // Invoke the super class (Object) constructor
+        methodWriter.visitInsn(RETURN);
+        methodWriter.visitMaxs(0, 0); // Auto-generated
+        methodWriter.visitEnd();
+        // Generate execute(Listener, Event)V throws EventException
+        methodWriter = writer.visitMethod(ACC_PUBLIC + ACC_FINAL, "execute", EXECUTE_DESCRIPTOR, null, new String[]{EventExecutor.INTERNAL_NAME});
+        methodWriter.visitCode();
+        generateExecute(methodWriter, method); // Generate the code
+        methodWriter.visitMaxs(0, 0); // Auto-generated
+        methodWriter.visitEnd();
+
+        GeneratedClassLoader loader = GeneratedClassLoader.getLoader(parent);
+        Class<? extends EventExecutor> clazz = loader.define(writer, name).asSubclass(EventExecutor.class);
+        try {
+            return clazz.newInstance();
+        } catch (Exception e) {
+            throw new AssertionError("Generated constructor must be public and not throw exceptions", e);
+        }
+    }
+
+    private static void generateExecute(MethodVisitor writer, Method method) {
+        Class<? extends Listener> listenerClass = method.getDeclaringClass().asSubclass(Listener.class);
+        Class<? extends Event> eventClass = method.getParameterTypes()[0].asSubclass(Event.class);
+        Label startTryBlock = new Label();
+        Label endTryBlock = new Label();
+        Label startCatchBlock = new Label();
+        Label endCatchBlock = new Label();
+        final int arg1Id = 1;
+        final int arg2Id = 2;
+        final int originalVarId = 3;
+
+        writer.visitTryCatchBlock(startTryBlock, endTryBlock, startCatchBlock, Type.getInternalName(Throwable.class)); // try {} catch (Throwable t)
+        writer.visitLabel(startTryBlock); // try {
+
+        writer.visitVarInsn(ALOAD, arg1Id); // Load listener onto the stack
+        writer.visitTypeInsn(CHECKCAST, Type.getInternalName(listenerClass)); // Check (Listener listener) instanceof method.getDeclaringClass()
+        writer.visitVarInsn(ALOAD, arg2Id); // Load event onto the stack
+        writer.visitTypeInsn(CHECKCAST, Type.getInternalName(eventClass)); // Check [Listener](Event event) instanceof eventClass
+        String ownerName = Type.getInternalName(method.getDeclaringClass());
+        String methodName = method.getName();
+        String descriptor = Type.getMethodDescriptor(method);
+        writer.visitMethodInsn(INVOKEVIRTUAL, ownerName, methodName, descriptor, method.getDeclaringClass().isInterface()); // Invoke the given method with (Listener listener, Event event)
+        writer.visitInsn(RETURN);
+        writer.visitLabel(endTryBlock); // end try
+        writer.visitLabel(startCatchBlock); // catch (Throwable original) {
+        // Now the only thingy on the stack should be (Throwable original)
+        writer.visitVarInsn(ASTORE, originalVarId); // Store (Throwable original)
+        writer.visitTypeInsn(NEW, EventException.INTERNAL_NAME); // Create a new instance of EventException
+        writer.visitInsn(DUP); // Duplicate (EventException exception) to (EventException, EventException exception)
+        writer.visitVarInsn(ALOAD, originalVarId); // Load original exception (Event
+        writer.visitMethodInsn(INVOKESPECIAL, EventException.INTERNAL_NAME, "<init>", "(Ljava/lang/Throwable;)V", false); // Call the constructor with [EventException](EventException exception, Throwable original
+        writer.visitInsn(ATHROW); // Throw (EventException exception)
+        writer.visitLabel(endCatchBlock); // end catch
+    }
+
+    public static EventExecutor newJREEventExecutor(Method method) {
+        validate(method);
+        Class<? extends Listener> listenerClass = method.getDeclaringClass().asSubclass(Listener.class);
+        Class<? extends Event> eventClass = method.getParameterTypes()[0].asSubclass(Event.class);
+        return new JREEventExecutor(method, listenerClass, eventClass);
+    }
+
+    private static void validate(Method method) {
+        Preconditions.checkArgument(Listener.class.isAssignableFrom(method.getDeclaringClass()), "The declaring class (%s) is not a Listener", method.getDeclaringClass().getName());
+        Preconditions.checkArgument(method.getParameterCount() == 1, "More than one parameter");
+        Preconditions.checkArgument(Event.class.isAssignableFrom(method.getParameterTypes()[0]), "The first parameter (%s) is not an Event", method.getParameterTypes()[0].getName());
+    }
+
+    public static EventExecutor newEventExecutor(Method method, ClassLoader parent) {
+        boolean isPublic = Modifier.isPublic(method.getModifiers());
+        return isUseAsmForEvents() && isPublic ? newASMEventExecutor(method, parent) : newJREEventExecutor(method);
+    }
+
+    private static class JREEventExecutor implements EventExecutor {
+        private final Method method;
+        private final Class<? extends Listener> listenerClass;
+        private final Class<? extends Event> eventClass;
+
+        public JREEventExecutor(Method method, Class<? extends Listener> listenerClass, Class<? extends Event> eventClass) {
+            this.method = method;
+            this.listenerClass = listenerClass;
+            this.eventClass = eventClass;
+        }
+
+        @Override
+        public final void execute(Listener listener, Event event) throws EventException {
+            listener = listenerClass.cast(listener); // Check cast
+            event = eventClass.cast(event); // Check cast
+            try {
+                method.invoke(listener, event);
+            } catch (IllegalAccessException e) {
+                throw new AssertionError("setAccessible() did not work", e);
+            } catch (InvocationTargetException e) {
+                Throwable cause = e.getCause();
+                if (cause == null) cause = e;
+                throw new EventException(cause);
+            }
+        }
+    }
+
+    // Command line options and overrides
+
+
+    private static int useAsmForEvents = -1;
+    public static boolean isUseAsmForEvents() {
+        if (useAsmForEvents == 0) return true;
+        else if (useAsmForEvents == 1) return false;
+        else {
+            String property = System.getProperty("taco.use-asm-for-events", "true");
+            setUseAsmForEvents(Boolean.parseBoolean(property));
+            return isUseAsmForEvents();
+        }
+    }
+
+    public static void setUseAsmForEvents(boolean asm) {
+        useAsmForEvents = asm ? 0 : 1;
+    }
+
+    public static void unsetUseAsmForEvents() {
+        useAsmForEvents = -1;
+    }
+
+}
diff --git a/src/main/java/net/techcable/tacospigot/GeneratedClassLoader.java b/src/main/java/net/techcable/tacospigot/GeneratedClassLoader.java
new file mode 100644
index 0000000..ca39b48
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/GeneratedClassLoader.java
@@ -0,0 +1,40 @@
+package net.techcable.tacospigot;
+
+import com.google.common.collect.MapMaker;
+import com.google.common.collect.Maps;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Type;
+
+import java.lang.ref.WeakReference;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public class GeneratedClassLoader extends ClassLoader {
+    static {
+        ClassLoader.registerAsParallelCapable();
+    }
+
+    public GeneratedClassLoader(ClassLoader parent) {
+        super(parent);
+    }
+
+
+    public Class<?> define(ClassWriter writer, String className) {
+        className = className.replace('/', '.');
+        byte[] bytes = writer.toByteArray();
+        synchronized (getClassLoadingLock(className)) {
+            Class<?> clazz = defineClass(className, bytes, 0, bytes.length);
+            resolveClass(clazz);
+            return clazz;
+        }
+    }
+
+    private static GeneratedClassLoader lastLoader;
+    public static GeneratedClassLoader getLoader(ClassLoader parent) {
+        GeneratedClassLoader loader = GeneratedClassLoader.lastLoader;
+        if (loader != null && loader.getParent() == parent) return loader;
+        loader = new GeneratedClassLoader(parent);
+        GeneratedClassLoader.lastLoader = loader;
+        return loader;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/EventException.java b/src/main/java/org/bukkit/event/EventException.java
index 84638e8..9fe7f8e 100644
--- a/src/main/java/org/bukkit/event/EventException.java
+++ b/src/main/java/org/bukkit/event/EventException.java
@@ -1,6 +1,7 @@
 package org.bukkit.event;
 
 public class EventException extends Exception {
+    public static final String INTERNAL_NAME = org.objectweb.asm.Type.getInternalName(EventException.class); // TacoSpigot
     private static final long serialVersionUID = 3532808232324183999L;
     private final Throwable cause;
 
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
index 3b2c99e..0061f17 100644
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ b/src/main/java/org/bukkit/plugin/EventExecutor.java
@@ -8,5 +8,6 @@ import org.bukkit.event.Listener;
  * Interface which defines the class for event call backs to plugins
  */
 public interface EventExecutor {
+    public static final String INTERNAL_NAME = org.objectweb.asm.Type.getInternalName(EventExecutor.class); // TacoSpigot
     public void execute(Listener listener, Event event) throws EventException;
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 7bf2fa6..948c365 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -17,6 +17,8 @@ import java.util.jar.JarFile;
 import java.util.logging.Level;
 import java.util.regex.Pattern;
 
+import net.techcable.tacospigot.EventExecutorFactory; // TacoSpigot
+
 import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
 import org.bukkit.Warning;
@@ -293,24 +295,29 @@ public final class JavaPluginLoader implements PluginLoader {
                 }
             }
 
+            EventExecutor asm = EventExecutorFactory.newEventExecutor(method, listener.getClass().getClassLoader()); // TacoSpigot - generate ASM
             final CustomTimingsHandler timings = new CustomTimingsHandler("Plugin: " + plugin.getDescription().getFullName() + " Event: " + listener.getClass().getName() + "::" + method.getName()+"("+eventClass.getSimpleName()+")", pluginParentTimer); // Spigot
             EventExecutor executor = new EventExecutor() {
                 public void execute(Listener listener, Event event) throws EventException {
-                    try {
+                    // try { // TacoSpigot - asm handles try catch
                         if (!eventClass.isAssignableFrom(event.getClass())) {
                             return;
                         }
                         // Spigot start
                         boolean isAsync = event.isAsynchronous();
                         if (!isAsync) timings.startTiming();
-                        method.invoke(listener, event);
+                        asm.execute(listener, event); // TacoSpigot - use asm
                         if (!isAsync) timings.stopTiming();
                         // Spigot end
+                    // TacoSpigot start - asm handles try catch
+                    /*
                     } catch (InvocationTargetException ex) {
                         throw new EventException(ex.getCause());
                     } catch (Throwable t) {
                         throw new EventException(t);
                     }
+                    */
+                    // TacoSpigot end
                 }
             };
             if (false) { // Spigot - RL handles useTimings check now
diff --git a/src/test/java/org/bukkit/TestServer.java b/src/test/java/org/bukkit/TestServer.java
index 2d84032..a5a2911 100644
--- a/src/test/java/org/bukkit/TestServer.java
+++ b/src/test/java/org/bukkit/TestServer.java
@@ -19,6 +19,7 @@ public class TestServer implements InvocationHandler {
 
     private static final Map<Method, MethodHandler> methods;
 
+    public static Boolean sync = null; // TacoSpigot
     static {
         try {
             ImmutableMap.Builder<Method, MethodHandler> methodMap = ImmutableMap.builder();
@@ -26,7 +27,12 @@ public class TestServer implements InvocationHandler {
                     Server.class.getMethod("isPrimaryThread"),
                     new MethodHandler() {
                         public Object handle(TestServer server, Object[] args) {
-                            return Thread.currentThread().equals(server.creatingThread);
+                            // TacoSpigot start - add an isPrimaryThread() override
+                            Boolean sync = TestServer.sync;
+                            if (sync == null) {
+                                return Thread.currentThread().equals(server.creatingThread);
+                            } else return sync;
+                            // TacoSpigot end
                         }
                     }
                 );
diff --git a/src/test/java/org/bukkit/event/SyntheticEventTest.java b/src/test/java/org/bukkit/event/SyntheticEventTest.java
index df6cf00..7e8f59e 100644
--- a/src/test/java/org/bukkit/event/SyntheticEventTest.java
+++ b/src/test/java/org/bukkit/event/SyntheticEventTest.java
@@ -1,17 +1,77 @@
 package org.bukkit.event;
 
+
 import org.bukkit.TestServer;
+import org.bukkit.plugin.EventExecutor;
 import org.bukkit.plugin.PluginLoader;
 import org.bukkit.plugin.SimplePluginManager;
 import org.bukkit.plugin.TestPlugin;
 import org.bukkit.plugin.java.JavaPluginLoader;
 import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
 import org.junit.Test;
 
+// TacoSpigot start
+import java.lang.reflect.Method;
+
+import net.techcable.tacospigot.EventExecutorFactory;
+
+import static org.junit.Assert.*;
+// TacoSpigot end
+
 public class SyntheticEventTest {
-    @SuppressWarnings("deprecation")
+    // TacoSpigot start - test both jre and asm reflection
+    public static final boolean PROFILE = false;
+    @Before
+    public void warmupASM() {
+        if (!PROFILE) return;
+        EventExecutorFactory.setUseAsmForEvents(true);
+        // Warmup the code generation
+        Method method = null;
+        try {
+            method = Impl.class.getDeclaredMethod("accept", TestEvent.class);
+        } catch (NoSuchMethodException e) {
+            throw new AssertionError("Test changed", e);
+        }
+        EventExecutor[] executors = new EventExecutor[1000];
+        for (int i = 0; i < 1000; i++) {
+            Impl impl = new Impl();
+            executors[i] = EventExecutorFactory.newEventExecutor(method, impl.getClass().getClassLoader());
+        }
+        // Warmup the code execution
+        test();
+        EventExecutorFactory.unsetUseAsmForEvents();
+    }
+
+    @Before
+    public void warmupJRE() {
+        if (!PROFILE) return;
+        // Warmup the code execution
+        EventExecutorFactory.setUseAsmForEvents(false);
+        test();
+        EventExecutorFactory.unsetUseAsmForEvents();
+    }
+
+    @Test
+    public void testASM() throws NoSuchMethodException {
+        EventExecutorFactory.setUseAsmForEvents(true);
+        test();
+        EventExecutorFactory.unsetUseAsmForEvents();
+    }
+
     @Test
+    public void testJRE() {
+        EventExecutorFactory.setUseAsmForEvents(false);
+        test();
+        EventExecutorFactory.unsetUseAsmForEvents();
+    }
+
+    @SuppressWarnings("deprecation")
+    // @Test
+    // TacoSpigot end
     public void test() {
+        TestServer.sync = false; // TacoSpigot - fool callers into thinking we are async
         final JavaPluginLoader loader = new JavaPluginLoader(TestServer.getInstance());
         TestPlugin plugin = new TestPlugin(getClass().getName()) {
             @Override
@@ -21,20 +81,26 @@ public class SyntheticEventTest {
         };
         SimplePluginManager pluginManager = new SimplePluginManager(TestServer.getInstance(), null);
 
-        TestEvent event = new TestEvent(false);
+        TestEvent event = new TestEvent(true); // TacoSpigot - be async to avoid timings code
         Impl impl = new Impl();
 
         pluginManager.registerEvents(impl, plugin);
-        pluginManager.callEvent(event);
+        // TacoSpigot start - call 1,000,000 times when profiling
+        int times = PROFILE ? 1000000 : 1;
+        for (int i = 0; i < times; i++) {
+            pluginManager.callEvent(event);
+        }
 
-        Assert.assertEquals(1, impl.callCount);
+        Assert.assertEquals(times, impl.callCount);
+        // TacoSpigot end
+        TestServer.sync = null; // TacoSpigot - reset to default behaviour
     }
 
     public static abstract class Base<E extends Event> implements Listener {
         int callCount = 0;
 
         public void accept(E evt) {
-            System.out.println("Invk " + evt);
+            // System.out.println("Invk " + evt); // TacoSpigot - lol nope
             callCount++;
         }
     }
-- 
2.4.6.windows.1.812.gd1b00d3

