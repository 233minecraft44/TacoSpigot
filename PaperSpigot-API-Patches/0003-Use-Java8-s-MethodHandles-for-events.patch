From 21e1ce9e3bfd9c41e93e3078da33be56879c9bb1 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Tue, 1 Sep 2015 18:20:18 -0700
Subject: [PATCH] Use Java8's MethodHandles for events

The JVM can optimize these just like a virtual method calls.
In addition, no 'new Object[] {event}' is created for the virtual method calls

diff --git a/src/main/java/net/techcable/tacospigot/EventExecutorFactory.java b/src/main/java/net/techcable/tacospigot/EventExecutorFactory.java
new file mode 100644
index 0000000..8c3fbd0
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/EventExecutorFactory.java
@@ -0,0 +1,101 @@
+package net.techcable.tacospigot;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class EventExecutorFactory {
+    private EventExecutorFactory() {
+    }
+
+    public static EventExecutor newMethodHandleEventExecutor(Method method) {
+        validate(method);
+        method.setAccessible(true);
+        try {
+            return new MethodHandleEventExecutor(MethodHandles.lookup().unreflect(method));
+        } catch (IllegalAccessException e) {
+            throw new AssertionError("Couldn't access", e);
+        }
+    }
+
+    public static EventExecutor newJREEventExecutor(Method method) {
+        validate(method);
+        Class<? extends Listener> listenerClass = method.getDeclaringClass().asSubclass(Listener.class);
+        Class<? extends Event> eventClass = method.getParameterTypes()[0].asSubclass(Event.class);
+        return new JREEventExecutor(method, listenerClass, eventClass);
+    }
+
+    private static void validate(Method method) {
+        Preconditions.checkArgument(Listener.class.isAssignableFrom(method.getDeclaringClass()), "The declaring class (%s) is not a Listener", method.getDeclaringClass().getName());
+        Preconditions.checkArgument(method.getParameterCount() == 1, "More than one parameter");
+        Preconditions.checkArgument(Event.class.isAssignableFrom(method.getParameterTypes()[0]), "The first parameter (%s) is not an Event", method.getParameterTypes()[0].getName());
+    }
+
+    public static EventExecutor newEventExecutor(Method method, ClassLoader parent) {
+        return isUseMethodHandles() ? newMethodHandleEventExecutor(method) : newJREEventExecutor(method);
+    }
+
+    private static class JREEventExecutor implements EventExecutor {
+        private final Method method;
+        private final Class<? extends Listener> listenerClass;
+        private final Class<? extends Event> eventClass;
+
+        public JREEventExecutor(Method method, Class<? extends Listener> listenerClass, Class<? extends Event> eventClass) {
+            this.method = method;
+            this.listenerClass = listenerClass;
+            this.eventClass = eventClass;
+        }
+
+        @Override
+        public final void execute(Listener listener, Event event) throws EventException {
+            listener = listenerClass.cast(listener); // Check cast
+            event = eventClass.cast(event); // Check cast
+            try {
+                method.invoke(listener, event);
+            } catch (IllegalAccessException e) {
+                throw new AssertionError("setAccessible() did not work", e);
+            } catch (InvocationTargetException e) {
+                Throwable cause = e.getCause();
+                if (cause == null) cause = e;
+                throw new EventException(cause);
+            }
+        }
+    }
+
+    private static class MethodHandleEventExecutor implements EventExecutor {
+        private final MethodHandle handle;
+
+        private MethodHandleEventExecutor(MethodHandle handle) {
+            this.handle = handle;
+        }
+
+        @Override
+        public final void execute(Listener listener, Event event) throws EventException {
+            try {
+                handle.invoke(listener, event);
+            } catch (Throwable throwable) {
+                throw new EventException(throwable);
+            }
+        }
+    }
+
+    // Command line options and overrides
+
+    private static final boolean useMethodHandles = isMethodHandlesConfigured();
+
+    public static boolean isUseMethodHandles() {
+        return useMethodHandles;
+    }
+
+    private static boolean isMethodHandlesConfigured() {
+        return Boolean.parseBoolean(System.getProperty("tacospigot.useMethodHandle", "true"));
+    }
+
+}
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 4983ea8..05d7edb 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -17,6 +17,8 @@ import java.util.jar.JarFile;
 import java.util.logging.Level;
 import java.util.regex.Pattern;
 
+import net.techcable.tacospigot.EventExecutorFactory; // TacoSpigot
+
 import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
 import org.bukkit.Warning;
@@ -291,20 +293,10 @@ public final class JavaPluginLoader implements PluginLoader {
                 }
             }
 
-            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(new EventExecutor() { // Spigot
-                public void execute(Listener listener, Event event) throws EventException {
-                    try {
-                        if (!eventClass.isAssignableFrom(event.getClass())) {
-                            return;
-                        }
-                        method.invoke(listener, event);
-                    } catch (InvocationTargetException ex) {
-                        throw new EventException(ex.getCause());
-                    } catch (Throwable t) {
-                        throw new EventException(t);
-                    }
-                }
-            }, plugin, method, eventClass); // Spigot
+            // TacoSpigot start - generate bytecode to invoke each event handler
+            EventExecutor generated = EventExecutorFactory.newEventExecutor(method, listener.getClass().getClassLoader());
+            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(generated, plugin, method, eventClass); // Spigot
+            // TacoSpigot end
             if (false) { // Spigot - RL handles useTimings check now
                 eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
             } else {
-- 
2.7.0

